<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>keytool-Key and Certificate Management Tool</title>

<!-- base href="http://java.sun.com/j2se/1.6.0/docs/tooldocs/solaris/keytool.html" --><link rel="stylesheet" href="../../../technotes/css/guide.css" />
</head>

<body>
<!-- STATIC HEADER -->

<table width="100%"><tr><td valign="bottom" align="left"><img src="../../../images/javalogo.gif"></td><td valign="bottom" align="right"><a href="../../../index.html"><font size="-1">Documentation Contents</font></a></td></tr></table>
<h1>keytool - Key and Certificate Management Tool</h1>
<blockquote>
Manages a keystore (database) of cryptographic keys, X.509 certificate chains,
and trusted certificates.
</blockquote>

<h2>SYNOPSIS</h2>
<blockquote>
<pre><strong>keytool</strong> [ <a href="#Commands">commands</a> ]
</pre>
<p>
The keytool command interface has changed in Java SE 6.
See the <a href="#Changes">Changes</a> Section for a detailed description.
Note that previously defined commands are still supported.
</p>
</blockquote>

<h2>DESCRIPTION</h2>

<blockquote>

<b>keytool</b> is a key and certificate management utility. It allows
users to administer
their own public/private key pairs and associated certificates for use
in self-authentication (where the user authenticates himself/herself
to other users/services) or data integrity and authentication
services, using digital signatures.
It also allows users to cache the public keys (in the form of certificates)
of their communicating peers.

<p>A <i>certificate</i> is a digitally signed statement
from one entity (person, company, etc.), saying that the
public key (and some other information)
of some other entity has a
particular value. (See <a href="#Certificates">Certificates</a>.)
When data is digitally signed, the signature can be verified to
check the data integrity and authenticity.
<i>Integrity</i> means that the data has not been
modified or tampered with, and <i>authenticity</i> means the data indeed
comes from whoever claims to have created and signed it.

</p><p><b>keytool</b> also enables users to administer secret keys used in symmetric
encryption/decryption (e.g. DES).

</p><p><b>keytool</b> stores the keys and certificates in a
<a href="#KeyStore"><i>keystore</i></a>.

<!--
</p><p>The <a href="http://java.sun.com/j2se/1.6.0/docs/tooldocs/solaris/jarsigner.html"><b>jarsigner</b></a> tool uses
information from a keystore to generate or verify digital signatures
for Java ARchive (JAR) files. (A JAR file packages class files, images,
sounds, and/or other digital data in a single file).
<b>jarsigner</b> verifies the digital signature of a JAR file,
using the certificate that comes with it (it is included in
the signature block file of the JAR file), and then checks
whether or not the public key of that certificate is "trusted",
i.e., is contained in the specified keystore.

</p><p>The Java Runtime consults keystores to verify signatures on a signed
JAR file when the JAR is first loaded.  Administrators can
<a href="../../guides/security/PolicyFiles.html">
grant permissions</a> to different JAR files based on their respective signers.
These permissions are then checked by the access control framework when code
from the JAR file executes.
-->

</p></blockquote>


<h2><a name="CommandNotes">COMMAND AND OPTION NOTES</a></h2>

<blockquote>

<p>The various commands and their options are listed and described
<a href="#Commands">below</a> . Note:

</p><ul>

<li>All command and option names are preceded by a minus sign (-).<p>

</p></li><li>The options for each command may be provided in any
order.<p>

</p></li><li>All items not italicized or in braces or square brackets are required
to appear as is.<p>

</p></li><li>Braces surrounding an option generally signify that a
<a href="#OptionDefaults">default</a> value will be used if the option
is not specified on the command line. Braces are also used around the
<code>-v</code>, <code>-rfc</code>, and <code>-J</code> options,
which only have meaning if
they appear on the command line (that is, they don't have any "default"
values other than not existing).<p>

</p></li><li>Brackets surrounding an option signify that
the user is prompted for the value(s) if the option is not specified
on the command line. (For a <code>-keypass</code> option, if
you do not specify the option on the command
line, <b>keytool</b> will first attempt to use the keystore password
to recover the private/secret key, and if this fails, will then prompt you
for the private/secret key password.)<p>

</p></li><li>Items in italics (option values) represent the actual values
that must be supplied. For example, here is the format of the
<code>-printcert</code> command:

<pre>  keytool -printcert {-file <i>cert_file</i>} {-v}
</pre>

<p>When specifying a <code>-printcert</code> command, replace
<i>cert_file</i> with the actual file name, as in:

</p><pre>  keytool -printcert -file VScert.cer
</pre><p>

</p></li><li>Option values must be quoted if they contain a blank (space).<p>

</p></li><li>The <code>-help</code> command is the default. Thus, the command line

<pre>  keytool
</pre>

is equivalent to

<pre>  keytool -help
</pre>

</li></ul>


<h3><a name="OptionDefaults">Option Defaults</a></h3>

<blockquote>

Below are the defaults for various option values.

<pre>-alias "mykey"

-keyalg
    "DSA" (when using <a href="#genkeypairCmd">-genkeypair</a>)
    "DES" (when using <a href="#genseckeyCmd">-genseckey</a>)

-keysize
    1024 (when using <a href="#genkeypairCmd">-genkeypair</a>)
    56 (when using <a href="#genseckeyCmd">-genseckey</a> and -keyalg is "DES")
    168 (when using <a href="#genseckeyCmd">-genseckey</a> and -keyalg is "DESede")

-validity 90

-keystore <i>the file named <code>.keystore</code> in the user's home directory</i>

-storetype <i>the value of the "keystore.type" property in the security properties file,
           which is returned by the static <code>getDefaultType</code> method in <code>java.security.KeyStore</code></i>

-file <i>stdin if reading, stdout if writing</i>

-protected false

</pre>

In generating a public/private key pair,
the signature algorithm (<i>-sigalg</i> option) is derived from the
algorithm of the underlying private key: If the underlying private key
is of type "DSA", the <i>-sigalg</i> option defaults to "SHA1withDSA",
and if the underlying private key is of type "RSA", <i>-sigalg</i>
defaults to "MD5withRSA". Please consult the
<a href="../../guides/security/crypto/CryptoSpec.html#AppA">
Java Cryptography Architecture API Specification & Reference</a> for a full list
of <i>-keyalg</i> and <i>-sigalg</i> you can choose from.

</blockquote>




<h3><a name="OptionsInAll">Common Options</a></h3>

<blockquote>

The <code>-v</code> option can appear for all commands except <code>-help</code>.
If it appears, it signifies "verbose" mode; more information will be output.

<p>There is also a <code>-J<i>javaoption</i></code> option that may appear
for any command. If it appears, the specified <i>javaoption</i> string is
passed through directly to the Java interpreter.
This option should not contain any spaces. It is useful for adjusting
the execution environment or memory usage.
For a list of possible interpreter
options, type <code>java -h</code> or <code>java -X</code> at the command line.

</p><p>These options may appear for all commands operating on a
keystore:

</p><dl><dt><code>-storetype <i>storetype</i></code>
</dt><dd>
This qualifier specifies the type of keystore to be instantiated.

<p></p></dd><dt><code>-keystore <i>keystore</i></code>
</dt><dd>
The keystore location.

<p> If the JKS <a href="#KeyStoreImplementation">storetype</a> is used and a
keystore file does not yet exist, then certain <b>keytool</b> commands may result
in a new keystore file being created.  For example, if
<code>keytool -genkeypair</code> is invoked and the <code>-keystore</code> option
is not specified, the default keystore file named <code>.keystore</code>
in the user's home directory will be created if it does not already exist.
Similarly, if the <code>-keystore <i>ks_file</i></code> option is specified
but <i>ks_file</i> does not exist, then it will be created

</p><p>Note that the input stream from the <code>-keystore</code>
option is passed to the <code>KeyStore.load</code>
method. If <code>NONE</code> is specified as the URL,
then a null stream is passed to the
<code>KeyStore.load</code> method.
<code>NONE</code> should be specified if the
<code>KeyStore</code> is not file-based (for example, if it
resides on a hardware token device).

</p></dd><dt><code>-storepass <i>storepass</i></code>
</dt><dd>
The password which is used to protect the integrity of the
keystore.

<p><em>storepass</em> must be at least 6 characters long.
It must be provided to all commands that access the keystore contents.
For such commands, if a <code>-storepass</code> option
is not provided at the command
line, the user is prompted for it.
</p><p>When retrieving information from the keystore, the password is
optional; if no password is given, the integrity of the retrieved
information cannot be checked and a warning is displayed.
</p></dd><dt><code>-providerName <i>provider_name</i></code>
</dt><dd>
Used to identify a cryptographic service provider's name when listed
in the security properties file.<p></p>

<p></p></dd><dt><code>-providerClass <i>provider_class_name</i></code>
</dt><dd>Used to specify the name of cryptographic service provider's master
class file when the service provider is not listed in the security
properties file.<p>

</p></dd><dt><code>-providerArg <i>provider_arg</i></code>
</dt><dd>
Used in conjunction with <code>-providerClass</code>.  Represents an
optional string input argument for the constructor of
<i>provider_class_name</i>.<p></p>

<p></p></dd><dt><code>-protected</code>
</dt><dd>
Either <code>true</code> or <code>false</code>.  This value should be
specified as <code>true</code> if a password must be given via a protected
authentication path such as a dedicated PIN reader.
<p></p></dd></dl>

</blockquote>



</blockquote>

<h2><a name="Commands">COMMANDS</a></h2>

<blockquote>

<h3>Creating or Adding Data to the Keystore</h3>

<blockquote>

<dl>

<dt><code><b><font size="+1"><a name="genkeypairCmd">-genkeypair </a></font></b>
  {-alias <i>alias</i>}
  {-keyalg <i>keyalg</i>}
  {-keysize <i>keysize</i>} {-sigalg <i>sigalg</i>} [-dname <i>dname</i>]
  [-keypass <i>keypass</i>] {-validity <i>valDays</i>}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Generates a key pair (a public key and associated private key).
Wraps the public key into an X.509 v3 self-signed certificate, which is
stored as a single-element certificate chain. This certificate chain and the
private key are stored in a new keystore entry
identified by <em>alias</em>.

</p><p><em>keyalg</em> specifies the algorithm to be used to generate the key pair,
and <em>keysize</em> specifies the size of each key to be generated.
<em>sigalg</em> specifies the algorithm that should be used to sign the
self-signed certificate; this algorithm must be compatible with
<em>keyalg</em>.

</p><p><em>dname</em> specifies the <a href="#DName">X.500 Distinguished Name</a>
to be associated with <em>alias</em>, and is used as the <code>issuer</code>
and <code>subject</code> fields in the self-signed certificate.
If no distinguished name is provided at the command line, the user will
be prompted for one.

</p><p><em>keypass</em> is a password used to protect the
private key of the generated key pair. If no password is provided,
the user is prompted for it. If you press RETURN at the prompt, the
key password is set to the same password as that used for the
keystore. <em>keypass</em> must be at least 6 characters long.

</p><p><em>valDays</em> tells the number of days for which the certificate
should be considered valid.</p>
<p>This command was named <tt>-genkey</tt> in previous releases.
 This old name is still supported in this release and will be
 supported in future releases, but for clarify the new name,
 <tt>-genkeypair</tt>, is preferred going forward. </p>
</dd>

<dt><code><b><font size="+1"><a name="genseckeyCmd">-genseckey </a></font></b>
  {-alias <i>alias</i>}
  {-keyalg <i>keyalg</i>}
  {-keysize <i>keysize</i>}
  [-keypass <i>keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>Generates a secret key and stores it in a new <code>KeyStore.SecretKeyEntry</code>
identified by <em>alias</em>.
</p><p>
<em>keyalg</em> specifies the algorithm to be used to generate the secret
key, and <em>keysize</em> specifies
the size of the key to be generated. <em>keypass</em>
is a password used to protect the
secret key. If no password is provided, the
user is prompted for it. If you press RETURN at the prompt, the
key password is set to the same password as that used for the
keystore. <em>keypass</em> must be at least 6 characters long.
</p></dd>

<dt><code><b><font size="+1"><a name="importCertCmd">-importcert</a></font></b>
  {-alias <i>alias</i>}
  {-file <i>cert_file</i>} [-keypass <i>keypass</i>]
  {-noprompt} {-trustcacerts}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Reads the certificate or certificate chain (where the latter is
supplied in a PKCS#7 formatted reply) from the file <i>cert_file</i>, and
stores it in the keystore entry identified by <i>alias</i>. If no file is
given, the certificate or PKCS#7 reply is read from stdin.

</p><p><b>keytool</b> can import X.509 v1, v2, and v3 certificates, and PKCS#7
formatted certificate chains consisting of certificates of that
type. The data to be imported must be provided either in binary
encoding format, or in printable encoding format (also known as Base64
encoding) as defined by the <a href="#EncodeCertificate">
Internet RFC 1421 standard</a>. In the latter
case, the encoding must be bounded at the beginning by a string that
starts with "-----BEGIN", and bounded at the end by a string that
starts with "-----END".

</p><p>You import a certificate for two reasons: </p><p>

</p><ol>

<li>to add it to the list of trusted certificates, or<p>
</p></li><li>to import a certificate reply received from a CA as the result of submitting
a Certificate Signing Request (see the <a href="#certreqCmd">-certreq</a> command)
to that CA.

</li></ol>

<p> Which type of import is intended is indicated by the value of the
<code>-alias</code> option:

</p><ol>

<p></p><li><b>If the alias does not point to a key entry</b>,
then <b>keytool</b> assumes you are adding a trusted certificate entry.
In this case, the alias should not already exist in the keystore.
If the alias does already exist, then <b>keytool</b> outputs an error,
since there is already a trusted certificate for that alias,
and does not import the certificate.
<p>

</p></li><li><b>If the alias points to a key entry</b>, then <b>keytool</b> assumes
you are importing a certificate reply.

</li></ol>

<h4>Importing a New Trusted Certificate</h4>

<blockquote>

<p>Before adding the certificate to the keystore,
<b>keytool</b> tries to verify it by attempting to construct a chain of trust
from that certificate to a self-signed certificate (belonging to a root
CA), using trusted certificates that are already available in the
keystore.

</p><p>If the <code>-trustcacerts</code> option has been specified, additional
certificates are considered for the chain of trust, namely the
certificates in a <a href="#cacerts">file named "cacerts"</a>.

</p><p>If <b>keytool</b> fails to establish a trust path from the certificate
to be imported up to a self-signed certificate (either from the keystore or
the "cacerts" file), the certificate information is printed out, and
the user is prompted to verify it, e.g., by comparing the displayed
certificate fingerprints with the fingerprints obtained from some
other (trusted) source of information, which might be the certificate
owner himself/herself. Be very careful to ensure the certificate is
valid prior to importing it as a "trusted" certificate! -- see
<a href="#TrustedCertWarning">
WARNING Regarding Importing Trusted Certificates</a>.
The user then has the option of
aborting the import operation. If the <code>-noprompt</code> option
is given, however, there will be no interaction with the user.

</p></blockquote>


<h4>Importing a Certificate Reply</h4>

<blockquote>

<p>When importing a certificate reply, the certificate reply is validated
using trusted certificates from the keystore, and optionally using the
certificates configured in the
<a href="#cacerts">"cacerts" keystore file</a> (if the
<code>-trustcacerts</code> option was specified).

</p><p>The methods of determining whether the certificate reply is
trusted are described in the following: </p><p>

</p><ul>

<li><b>If the reply is a single X.509 certificate</b>, <b>keytool</b> attempts
to establish a trust chain, starting at the certificate reply and ending
at a self-signed certificate (belonging to a root CA). The certificate
reply and the hierarchy of certificates used to authenticate the
certificate reply form the new certificate chain of <i>alias</i>.
If a trust chain cannot be established, the certificate reply is not
imported. In this case, <b>keytool</b> does not print out the certificate and
prompt the user to verify it, because it is very hard (if not impossible)
for a user to determine the authenticity of the certificate reply. <p>

</p></li><li><b>If the reply is a PKCS#7 formatted certificate chain</b>,
the chain is first ordered (with the user certificate first and the self-signed
root CA certificate last), before <b>keytool</b> attempts to match the root
CA certificate provided in the reply with any of the trusted
certificates in the keystore or the "cacerts" keystore file (if the
<code>-trustcacerts</code> option was specified). If no match can be found, the
information of the root CA certificate is printed out, and the user is
prompted to verify it, e.g., by comparing the displayed certificate
fingerprints with the fingerprints obtained from some other (trusted)
source of information, which might be the root CA itself. The user
then has the option of aborting the import operation. If the
<code>-noprompt</code>
option is given, however, there will be no interaction with the user.

</li></ul>

<p> If the public key in the certificate reply matches the user's public key
already stored with under <i>alias</i>, the old certificate chain is replaced
with the new certificate chain in the reply.  The old chain can only be
replaced if a valid <i>keypass</i>, the password used to protect the
private key of the entry, is supplied. If no password is provided,
and the private key password is different from the keystore password,
the user is prompted for it.

</p></blockquote>
<p></p>
<p>This command was named <tt>-import</tt> in previous releases.
 This old name is still supported in this release and will be
 supported in future releases, but for clarify the new name,
 <tt>-importcert</tt>, is preferred going forward. </p>
</dd>

<!--dt><code><b><font size="+1"><a name="selfcertCmd">-selfcert </a></font></b>
  {-alias <i>alias</i>}
  {-sigalg <i>sigalg</i>} {-dname <i>dname</i>}
  {-validity <i>valDays</i>} [-keypass <i>keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Generates an X.509 v3 self-signed certificate,
using keystore information including the private key and
public key associated with <em>alias</em>. If <i>dname</i> is
supplied at the command line, it is used as the
<a href="#DName">X.500 Distinguished Name</a> for
both the <code>issuer</code> and <code>subject</code> of the
certificate. Otherwise, the X.500 Distinguished Name associated
with <em>alias</em> (at the bottom of its existing certificate
chain) is used.

</p><p>The generated certificate is stored as a single-element certificate chain
in the keystore entry identified by <em>alias</em>, where it replaces the
existing certificate chain.

</p><p><em>sigalg</em> specifies the algorithm that should be used to
sign the certificate.

</p><p>In order to access the private key, the appropriate password must be
provided, since private keys
are protected in the keystore with a password. If <em>keypass</em> is not
provided at the command line, and is different from the password used to
protect the integrity of the keystore, the user is prompted for it.

</p><p><em>valDays</em> tells the number of days for which the certificate
should be considered valid.</p><p>


</p></dd-->
<!--dt><code><b><font size="+1"><a name="identitydbCmd">-identitydb </a></font></b>
  {-file <i>idb_file</i>}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Reads the JDK 1.1.x-style identity database from the file
<em>idb_file</em>, and adds its entries to the keystore.
If no file is given, the identity database is read from stdin.
If a keystore does not exist, it is created.

</p><p>Only identity database entries ("identities") that were marked as
trusted will
be imported in the keystore. All other identities will be ignored.
For each trusted identity, a keystore entry will be created.
The identity's name is used as the "alias" for the keystore entry.

</p><p>The private keys from trusted identities will all be encrypted
under the same password, <i>storepass</i>. This is the same password that
is used to protect the keystore's integrity.
Users can later assign individual passwords to those private keys
by using the "-keypasswd" <b>keytool</b> command option.

</p><p>An identity in an identity database may hold more than one
certificate, each certifying the same public key. But a keystore
key entry for a private key has that private key and
a single "certificate chain" (initially just a single certificate),
where the first certificate in the chain
contains the public key corresponding to the private key.
When importing the information from an identity, only the first
certificate of the identity is stored in the keystore.
This is because an identity's name in an
identity database is used as the alias for
its corresponding keystore entry, and alias names are unique
within a keystore,


</p></dd-->
<dt><code><b><font size="+1"><a name="importKeyStoreCmd">-importkeystore </a></font></b>
  -srckeystore <i>srckeystore</i> -destkeystore <i>destkeystore</i>
  {-srcstoretype <i>srcstoretype</i>} {-deststoretype <i>deststoretype</i>}
  [-srcstorepass <i>srcstorepass</i>] [-deststorepass <i>deststorepass</i>]
  {-srcprotected} {-destprotected}
  {-srcalias <i>srcalias</i>
    {-destalias <i>destalias</i>}
    [-srckeypass <i>srckeypass</i>]
    [-destkeypass <i>destkeypass</i>]
  }
  {-noprompt}
  {-srcProviderName <i>src_provider_name</i>}
  {-destProviderName <i>dest_provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
Imports a single entry or all entries from a source keystore to a destination
keystore.
</p><p>
When the <em>srcalias</em> option is provided, the command imports the single entry
identified by the alias to the destination keystore. If a destination alias is
not provided with <em>destalias</em>, then <em>srcalias</em> is used as the destination alias. If
the source entry is protected by a password, <em>srckeypass</em> will be used to recover
the entry. If <em>srckeypass</em> is not provided, then <b>keytool</b> will attempt to use
<em>srcstorepass</em> to recover the entry. If <em>srcstorepass</em> is either not provided or is
incorrect, the user will be prompted for a password. The destination entry will
be protected using <em>destkeypass</em>.  If <em>destkeypass</em> is not provided, the destination
entry will be protected with the source entry password.
</p><p>
If the <em>srcalias</em> option is not provided, then all entries in the source keystore
are imported into the destination keystore.  Each destination entry will be
stored under the alias from the source entry.  If the source entry is protected
by a password, <em>srcstorepass</em> will be used to recover the entry.  If <em>srcstorepass</em>
is either not provided or is incorrect, the user will be prompted for a
password.  If a source keystore entry type is not supported in the destination
keystore, or if an error occurs while storing an entry into the destination
keystore, the user will be prompted whether to skip the entry and continue, or
to quit.  The destination entry will be protected with the source entry password.
</p><p>
If the destination alias already exists in the destination keystore, the user is
prompted to either overwrite the entry, or to create a new entry under a
different alias name.
</p><p>
Note that if <code>-noprompt</code> is provided, the user will not be prompted for a new
destination alias.  Existing entries will automatically be overwritten with the
destination alias name.  Finally, entries that can not be imported are
automatically skipped and a warning is output.
</p>

<p></p>

      </dd>
    </dl>


</blockquote>



<h3>Exporting Data</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="certreqCmd">-certreq </a></font></b>{-alias <i>alias</i>}
  {-sigalg <i>sigalg</i>} {-file <i>certreq_file</i>}
  [-keypass <i>keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Generates a Certificate Signing Request (CSR), using the PKCS#10
format.

</p><p>A CSR is intended to be sent to a certificate authority (CA).
The CA will authenticate the certificate requestor (usually off-line)
and will return a certificate or certificate chain, used to replace the
existing certificate chain (which initially consists of a self-signed
certificate) in the keystore.

</p><p>The private key and X.500 Distinguished Name associated with
<em>alias</em> are used to create the PKCS#10 certificate request.
In order to access the private key, the appropriate password must be
provided, since private keys
are protected in the keystore with a password. If <em>keypass</em> is not
provided at the command line, and is different from the password used to
protect the integrity of the keystore, the user is prompted for it.</p>

<p><em>sigalg</em> specifies the algorithm that should be used to
sign the CSR.

</p><p>The CSR is stored in the file <em>certreq_file</em>. If no file is given,
the CSR is output to stdout.

</p><p>Use the <em>importcert</em> command to import the response from the
CA.</p><p>


</p></dd><dt><code><b><font size="+1"><a name="exportCertCmd">-exportcert</a></font></b>
  {-alias <i>alias</i>}
  {-file <i>cert_file</i>}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-rfc} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Reads (from the keystore) the certificate associated with
<em>alias</em>, and stores it in the file <em>cert_file</em>.

</p><p>If no file is given, the certificate is output to stdout.

</p><p>The certificate is by default output in binary encoding, but will instead
be output in the printable encoding format,
as defined by the <a href="#EncodeCertificate">Internet RFC 1421 standard</a>,
if the <code>-rfc</code> option is specified.

</p><p>If <i>alias</i> refers to a trusted certificate, that certificate is
output. Otherwise, <i>alias</i> refers to a key entry with
an associated certificate chain. In that case, the first certificate
in the chain is returned. This certificate authenticates the public key
of the entity addressed by <i>alias</i>.</p><p>

</p>
<p>This command was named <tt>-export</tt> in previous releases.
 This old name is still supported in this release and will be
 supported in future releases, but for clarify the new name,
 <tt>-exportcert</tt>, is preferred going forward. </p>
</dd></dl>

</blockquote>


<h3>Displaying Data</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="listCmd">-list </a></font></b> {-alias <i>alias</i>}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v | -rfc} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Prints (to stdout) the contents of the keystore entry identified by <i>alias</i>.
If no alias is specified, the contents of the entire keystore are
printed.

</p><p>This command by default prints the MD5 fingerprint
of a certificate. If the <code>-v</code> option is specified, the
certificate is printed in human-readable format, with
additional information such as the owner, issuer,
serial number, and any extensions. If the
<code>-rfc</code> option is specified, certificate contents
are printed using the printable encoding format, as defined by the
<a href="#EncodeCertificate">Internet RFC 1421 standard</a>

</p><p>You cannot specify both <code>-v</code> and <code>-rfc</code>.
</p><p></p></dd>

<dt><code><b><font size="+1"><a name="printcertCmd">-printcert </a></font><a name="printcertCmd"></a></b>
<a name="printcertCmd">  {-file <i>cert_file</i>}
  {-v} {-J<i>javaoption</i>}</a></code>
</dt><dd>
<p><a name="printcertCmd">Reads the certificate from the file <em>cert_file</em>, and prints
its contents in a human-readable format.
If no file is given, the certificate is read from stdin.

</a></p><p><a name="printcertCmd">The certificate may be either binary encoded or in printable encoding format,
as defined by the </a><a href="#EncodeCertificate">Internet RFC 1421 standard</a>.

</p><p>Note: This option can be used independently of a keystore.</p><p>


</p></dd>

</dl>

</blockquote>


<h3>Managing the Keystore</h3>

<blockquote>

<dl>
<!--dt><code><b><font size="+1"><a name="keycloneCmd">-keyclone </a></font></b>
  {-alias <i>alias</i>}
  [-dest <i>dest_alias</i>]
  [-keypass <i>keypass</i>] [-new <i>new_keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Creates a new keystore entry, which has the same private key and
certificate chain as the original entry if it's a private key entry, or has
the same secret key if it's a secret key entry.

</p><p>The original entry is identified by <em>alias</em> (which defaults
to "mykey" if not provided).
The new (destination) entry is identified by <em>dest_alias</em>.
If no destination alias is supplied at the command
line, the user is prompted for it.

</p><p>If the private/secret key password is different from the keystore password,
then the entry will only be cloned if a valid <i>keypass</i> is
supplied.  This is the password used to protect the key
associated with <i>alias</i>. If no key password is supplied at the command
line, and the key password is different from the keystore password,
the user is prompted for it.

The key in the cloned entry
may be protected with a different password, if desired. If no
<code>-new</code> option is supplied at the command line, the
user is prompted for the new entry's password (and may choose to
let it be the same as for the cloned entry's private/secret key).

</p></dd-->
<dt><code><b><font size="+1"><a name="storePasswdCmd">-storepasswd</a> </font></b>[-new <i>new_storepass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Changes the password used to protect the integrity of the
keystore contents. The new password is <em>new_storepass</em>,
which must be at least 6 characters long.</p>

<p>


</p></dd><dt><code><b><font size="+1"><a name="keyPasswdCmd">-keypasswd</a> </font></b>{-alias <i>alias</i>}
  [-keypass <i>old_keypass</i>] [-new <i>new_keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Changes the password under which the private/secret key identified by
<em>alias</em> is protected, from <em>old_keypass</em> to
<em>new_keypass</em>, which must be at least 6 characters long.

</p><p>If the <code>-keypass</code> option is not
provided at the command line, and the key password is
different from the keystore password, the user is prompted for it.

</p><p>If the <code>-new</code> option is not
provided at the command line, the user is prompted for it.</p><p>

</p><p>


</p></dd><dt><code><b><font size="+1"><a name="deleteCmd">-delete </a></font></b>
  [-alias <i>alias</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Deletes from the keystore the entry identified by <em>alias</em>.
The user is prompted for the alias, if no alias is provided at the
command line.</p><p>

</p></dd>
<dt><code><b><font size="+1"><a name="changeAliasCmd">-changealias</a> </font></b>
  {-alias <i>alias</i>} [-destalias <i>destalias</i>]
  [-keypass <i>keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
Move an existing keystore entry from the specified <em>alias</em> to a new
alias, <em>destalias</em>.  If no destination alias is provided, the command
will prompt for one.  If the original entry is protected with an entry
password, the password can be supplied via the "-keypass" option. If no key
password is provided, the <i>storepass</i> (if given) will be attempted
first.  If that attempt fails, the user will be prompted for a password.
</p></dd>
</dl>
</blockquote>


<h3>Getting Help</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="helpCmd">-help</a> </font></b></code>
</dt><dd>
<p>Lists the basic commands and their options.</p><p>


</p></dd>

</dl>

</blockquote>


</blockquote>





<h2><a name="EXAMPLES">EXAMPLES</a></h2>

<blockquote>

<p>Suppose you want to create a keystore for managing your
public/private key pair and certificates from entities you trust.

</p>
<!--h3>Generating a Secret Key</h3>

<blockquote>
<p>You can always generate a secret key in a keystore so that it can be used by
a Java program later. The command is very simple:

</p><pre>    keytool -genseckey -alias mysecret -keyalg DESede -keysize 112
      -keypass 426593 -keystore C:\working\mykeystore -storepass ab987c
</pre>

<p>This command create a DESede type secret key (with key size 112) in a keystore
based on the file C:\working\mykeystore. The storepass ab987c is needed to update
the keystore. The keypass 426593 is the protect password for the secret entry
itself. When the secret key is generated, it is stored as a KeyStore.SecretKeyEntry
in the key store which you can always use KeyStore.getKey() to retrieve.

</p><p>in order to see what kind of secret key you can create, you can refer to
<a href="../../technotes/guides/security/crypto/CryptoSpec.html#AppA">
http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</a>
to see what keyalg you can provide. Please take attention that although the
above link is titled SunJCE Default keysizes, that does not garantee keytool
will recognize it, you are still required to provide the keysize option yourself.
</p></blockquote>

</p-->

<h3>Generating Your Key Pair</h3>

<blockquote>

<p>The first thing you need to do is create a keystore and generate the
key pair. You could
use a command such as the following:

</p><pre>    keytool -genkeypair -dname "cn=Mark Jones, ou=JavaSoft, o=Sun, c=US"
      -alias business -keypass kpi135 -keystore C:\working\mykeystore
      -storepass ab987c -validity 180
</pre>

<p>(Please note: This must be typed as a single line. Multiple lines
are used in the examples just for legibility purposes.)

</p><p>This command creates the keystore named "mykeystore" in the "C:\working"
directory (assuming it doesn't already exist), and assigns it the password
"ab987c".
It generates a public/private key pair for the entity whose "distinguished
name" has a
common name of "Mark Jones", organizational unit of "JavaSoft", organization of
"Sun" and two-letter country code of "US".
It uses the default "DSA" key generation algorithm to create the keys,
both 1024 bits long.

</p><p>It creates a self-signed
certificate (using the default "SHA1withDSA" signature algorithm)
that includes the public key and
the distinguished name information. This certificate will be valid
for 180 days, and is associated
with the private key in a keystore entry referred to by the
alias "business". The private key is assigned the password "kpi135".

</p><p>The command could be significantly shorter if option defaults were accepted.
As a matter of fact, no options are required; defaults are used for
unspecified options that have default values, and you are prompted for any
required values. Thus, you could simply have the following:

</p><pre>    keytool -genkeypair
</pre>

In this case, a keystore entry with alias "mykey" is created, with a
newly-generated key pair and a certificate that is valid for 90 days. This entry
is placed in the keystore named ".keystore" in your
home directory. (The keystore is created if it doesn't already exist.)
You will be prompted for the distinguished name information, the
keystore password, and the private key password.

<p>The rest of the examples assume you executed the <code>-genkeypair</code> command
without options specified, and that you responded to the prompts with values
equal to those given in the first <code>-genkeypair</code> command, above (a private
key password of "kpi135", etc.)

</p></blockquote>


<h3>Requesting a Signed Certificate from a Certification Authority</h3>

<blockquote>

<p>So far all we've got is a self-signed certificate.
A certificate is more likely to be trusted by others if
it is signed by a Certification Authority (CA).
To get such a signature, you first generate a Certificate
Signing Request (CSR), via the following:

</p><pre>    keytool -certreq -file MarkJ.csr
</pre>

This creates a CSR (for the entity identified by the default alias
"mykey") and puts the request in the file named "MarkJ.csr". Submit this
file to a CA, such as VeriSign, Inc.
The CA will authenticate you, the requestor (usually off-line),
and then will return a certificate, signed by them, authenticating
your public key. (In some cases, they will actually return a
chain of certificates, each one authenticating the public key of
the signer of the previous certificate in the chain.)

</blockquote>


<h3>Importing a Certificate for the CA</h3>

<blockquote>

<p>You need to replace your self-signed certificate with a certificate
chain, where each certificate in the chain authenticates the public key of
the signer of the previous certificate in the chain, up to a "root" CA.

</p><p>Before you import the certificate reply from a CA, you need
one or more  "trusted certificates" in your keystore or in the
<code>cacerts</code> keystore file (which is described in
<a href="#importCertCmd">importcert command</a>):

</p><ul>

<li>If the certificate reply is a certificate chain,
you just need the top certificate of the chain (that is, the "root" CA
certificate authenticating that CA's public key).<p>

</p></li><li>If the certificate reply is a single certificate, you need a
certificate for the issuing CA (the one that signed it), and if that certificate is not
self-signed, you need a certificate for its signer, and so on,
up to a self-signed "root" CA certificate.

</li></ul>

<p>The "cacerts" keystore file ships with five VeriSign root CA
certificates, so you probably won't need to import a VeriSign
certificate as a trusted certificate in your keystore. But if
you request a signed certificate from a different CA, and a
certificate authenticating that CA's public key hasn't been
added to "cacerts", you will need to import a certificate
from the CA as a "trusted certificate".

</p><p>A certificate from a CA is usually either
self-signed, or signed by another CA (in which case you also need a
certificate authenticating that CA's public key). Suppose company
ABC, Inc., is a CA, and you obtain a
file named "ABCCA.cer" that is purportedly a self-signed certificate from
ABC, authenticating that CA's public key.

</p><p>Be very careful to ensure the certificate is
valid prior to importing it as a "trusted" certificate!
View it first (using the <b>keytool</b> <code>-printcert</code> command, or the
<b>keytool</b> <code>-importcert</code> command
without the <code>-noprompt</code> option),
and make sure that the displayed certificate fingerprint(s) match the
expected ones. You can call the person who sent the certificate,
and compare the fingerprint(s) that you see with the ones that they show
(or that a secure public key repository shows).
Only if the fingerprints are equal is it guaranteed that the certificate has not been
replaced in transit with somebody else's (for example, an attacker's) certificate.
If such an attack took place, and you did not check the certificate
before you imported it, you would end up trusting anything the
attacker has signed.

</p><p>If you trust that
the certificate is valid, then you can add it
to your keystore via the following:

</p><pre>    keytool -importcert -alias abc -file ABCCA.cer
</pre>

This creates a "trusted certificate" entry in the keystore, with
the data from the file "ABCCA.cer", and assigns the alias
"abc" to the entry.

</blockquote>


<h3>Importing the Certificate Reply from the CA</h3>

<blockquote>

<p>Once you've imported a certificate authenticating the public key of
the CA you submitted your certificate signing request to (or there's
already such a certificate in the "cacerts" file),
you can import the certificate reply and thereby
replace your self-signed certificate with a certificate
chain. This chain is the one returned by the CA in response to
your request (if the CA reply is a chain), or one constructed (if the
CA reply is a single certificate) using
the certificate reply and trusted certificates that are already available
in the keystore where you import the reply or in the
"cacerts" keystore file.

</p><p>For example, suppose you sent your certificate signing request to
VeriSign. You can then import the reply via
the following, which assumes the returned certificate is named "VSMarkJ.cer":

</p><pre>    keytool -importcert -trustcacerts -file VSMarkJ.cer
</pre>

</blockquote>


<h3>Exporting a Certificate Authenticating Your Public Key</h3>

<blockquote>

Suppose you have used the <a href="jarsigner.html">jarsigner</a> tool to sign a
Java ARchive (JAR) file.
Clients that want to use the file will want to authenticate your
signature.

<p>One way they can do this is by first importing your public key
certificate into their keystore as a "trusted" entry.
You can export the certificate and supply it to your clients.
As an example, you can copy your certificate
to a file named <code>MJ.cer</code> via the following, assuming
the entry is aliased by "mykey":

</p><pre>    keytool -exportcert -alias mykey -file MJ.cer
</pre>

Given that certificate, and the signed JAR file, a client can use
the <b>jarsigner</b> tool to authenticate your signature.

</blockquote>




<!--h3>Changing Your Distinguished Name but Keeping your Key Pair</h3>

<blockquote>

Suppose your distinguished name changes, for example because you have
changed departments or moved to a different city. If desired, you may
still use the public/private key pair you've previously used, and yet
update your distinguished name. For example, suppose your name is
Susan Miller, and you created your initial key entry with
the alias <code>sMiller</code> and the distinguished name

<pre>  "cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"
</pre>

Suppose you change from the Finance Department to the Accounting Department.
You can still use the previously-generated public/private key pair
and yet update your distinguished name by doing the following.

First, copy (clone) your key entry:

<pre>    keytool -keyclone -alias sMiller -dest sMillerNew
</pre>

(This prompts for the store password and for the
initial and destination private key
passwords, since they aren't provided at the command line.)
Now you need to change the certificate chain associated with
the copy, so that the first certificate in the chain uses your
different distinguished name. Start by generating a self-signed
certificate with the appropriate name:

<pre>    keytool -selfcert -alias sMillerNew
      -dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
</pre>

<p>Then generate a Certificate Signing Request based on the information
in this new certificate:

</p><pre>    keytool -certreq -alias sMillerNew
</pre>

When you get the CA certificate reply, import it:

<pre>    keytool -import -alias sMillerNew -file VSSMillerNew.cer
</pre>

After importing the certificate reply, you may want to remove the
initial key entry that used your old distinguished name:

<pre>    keytool -delete -alias sMiller
</pre>

</blockquote>
-->

<h3>Importing Keystore</h3>
<blockquote>
<p>The command "importkeystore" is used to import an entire keystore into
another keystore, which means all entries from the source keystore, including
keys and certificates, are all imported to the destination keystore within a
single command. You can use this command to import entries from a different type of keystore.
During the import, all new entries in the destination keystore will have the
same alias names and protection passwords (for secret keys and private keys).
If <b>keytool</b> has difficulties recover the private keys or secret keys from the
source keystore, it will prompt you for a password. If it detects alias
duplication, it will ask you for a new one, you can specify a new alias or
simply allow <b>keytool</b> to overwrite the existing one.</p>

<p>For example, to import entries from a normal JKS type keystore key.jks into a
PKCS #11 type hardware based keystore, you can use the command:</p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
</pre>
<p>The importkeystore command can also be used to import a single entry from a
source keystore to a destination keystore. In this case, besides the options you
see in the above example, you need to specify the alias you want to import. With
the srcalias option given, you can also specify the desination alias name in the
command line, as well as protection password for a secret/private key and the
destination protection password you want. In this way, you can issue a <b>keytool</b>
command that will never ask you a question. This makes it very convenient to
include a <b>keytool</b> command into a script file, like this:</p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
    -srcalias myprivatekey -destalias myoldprivatekey
    -srckeypass oldkeypass -destkeypass mynewkeypass
    -noprompt
</pre>

</blockquote>
</blockquote>


<h2>TERMINOLOGY and WARNINGS</h2>

<blockquote>

<a name="KeyStore"></a>
<h3>KeyStore</h3>

<blockquote>
A keystore is a storage facility for cryptographic keys and certificates.
</blockquote>

<ul>
<a name="KeyStoreEntries"></a>
<li><h4>KeyStore Entries</h4>

<blockquote>

Keystores may have different types of entries.  The two most applicable
entry types for <b>keytool</b> include:

<ol>

<li><b>key entries</b> - each holds very sensitive cryptographic key
information, which is stored in a protected format to prevent unauthorized
access. Typically, a key stored in this type of entry is a secret key, or a
private key accompanied by the
<a href="#CertChains">certificate "chain"</a> for the corresponding
public key. The <b>keytool</b> can handle both types od entry, while
 <b>jarsigner</b> tool only handle
the latter type of entry, that is private keys and their associated certificate
chains.<p>

</p></li><li><b>trusted certificate entries</b> - each contains a single public
key certificate belonging to another party. It is called a
"trusted certificate" because the keystore owner trusts that the public key
in the certificate indeed belongs to the identity identified by the
"subject" (owner) of the certificate.
The issuer of the certificate vouches for this, by signing
the certificate.

</li></ol>

</blockquote>



<a name="KeyStoreAliases"></a>
</li><li><h4>KeyStore Aliases</h4>

<blockquote>

<p>All keystore entries (key and trusted certificate
entries) are accessed via unique <i>aliases</i>.

</p><p>An alias is specified when you
add an entity to the keystore using the
<a href="#genseckeyCmd">-genseckey</a> command to generate a secret key,
<a href="#genkeypairCmd">-genkeypair</a> command to generate
a key pair (public and private key) or the
<a href="#importCertCmd">-importcert</a> command
to add a certificate or certificate chain to the list
of trusted certificates.
Subsequent <b>keytool</b> commands must
use this same alias to refer to the entity.

</p><p>For example, suppose you use the alias <tt>duke</tt> to generate
a new public/private key pair and wrap the public key into a self-signed
certificate (see <a href="#CertChains">Certificate Chains</a>)
via the following command:

</p><pre>    keytool -genkeypair -alias duke -keypass dukekeypasswd
</pre>

This specifies an inital password of "dukekeypasswd" required by
subsequent commands to access
the private key assocated with the alias <code>duke</code>.
If you later want to change
duke's private key password, you use a command like the following:

<pre>    keytool -keypasswd -alias duke -keypass dukekeypasswd -new newpass
</pre>

This changes the password from "dukekeypasswd" to "newpass".

<p>Please note: A password should not actually be specified on a
command line or in a script unless it is for testing purposes,
or you are on a secure system. If you don't specify a required
password option on a command line, you will be prompted for it.

</p></blockquote>


<a name="KeyStoreImplementation"></a>
</li><li><h4>KeyStore Implementation</h4>

<blockquote>

The <code>KeyStore</code> class provided in the
<code>java.security</code> package supplies
well-defined interfaces to access and modify the information
in a keystore. It is possible for there to be
multiple different concrete implementations, where each
implementation is that for a particular <i>type</i> of keystore.

<p>Currently, two command-line tools (<b>keytool</b> and <b>jarsigner</b>)
and a GUI-based tool named <b>Policy Tool</b> make use of
keystore implementations.
Since <code>KeyStore</code> is publicly available,   users can
write additional security applications that use it.

</p><p>There is a built-in default implementation, provided by
Sun Microsystems. It implements the keystore as a file, utilizing
a proprietary keystore type (format) named "JKS".
It protects each private key with its individual password, and also protects
the integrity of the entire keystore with a
(possibly different) password.

</p><p>Keystore implementations are provider-based. More specifically,
the application interfaces supplied by <code>KeyStore</code> are
implemented in terms of a "Service Provider Interface" (SPI).
That is, there is a corresponding abstract <code>KeystoreSpi</code> class,
also in the <code>java.security</code> package, which defines the Service
Provider Interface methods that "providers" must implement.
(The term "provider" refers to a package or a set of packages that supply
a concrete implementation of a subset of services that can be accessed
by the Java Security API.)
Thus, to provide a keystore implementation, clients must implement a
"provider" and supply a KeystoreSpi subclass implementation, as described in
<a href="../../guides/security/crypto/HowToImplAProvider.html">How to Implement a
Provider for the Java Cryptography Architecture</a>.

</p><p>Applications can choose different <i>types</i> of keystore implementations
from different providers, using the "getInstance" factory method supplied
in the <code>KeyStore</code> class.
A keystore type defines the storage and data format of the keystore
information, and the algorithms used to
protect private/secret keys in the keystore and the integrity of the keystore
itself. Keystore implementations of different types are not compatible.

</p><p><b>keytool</b> works on any file-based keystore
implementation. (It treats the keytore location that is passed to
it at the command line as a filename and converts it to a
FileInputStream, from which it loads the keystore information.)
The <b>jarsigner</b> and <b>policytool</b> tools, on the other hand,
can read a keystore from any location that can be specified
using a URL.

</p><p>For <b>keytool</b> and <b>jarsigner</b>, you can specify a keystore
type at the command line, via the <i>-storetype</i> option. For
<b>Policy Tool</b>, you can specify a keystore type via the "Keystore" menu.

</p><p>If you don't explicitly specify a keystore type,
the tools choose a keystore implementation based simply on
the value of the <code>keystore.type</code>
property specified in the security properties file.
The security properties file is called <tt>java.security</tt>, and
it resides in the   security properties directory,
<code><i>java.home</i>\lib\security</code>, where <i>java.home</i> is
the runtime environment's directory (the <tt>jre</tt> directory in the SDK or the top-level directory of the Java 2 Runtime Environment).

</p><p>Each tool gets the <code>keystore.type</code> value and then examines all
the currently-installed providers until it finds one that implements
keystores of that type. It then uses the keystore implementation
from that provider.

</p><p>The <code>KeyStore</code> class defines a static method named
<code>getDefaultType</code> that lets applications and applets
retrieve the value of the <code>keystore.type</code> property.
The following line of code creates an instance of the default
keystore type (as specified in the <code>keystore.type</code> property):

</p><pre>    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</pre>

<p>The default keystore type is "jks" (the proprietary type of the
keystore implementation provided by Sun). This is specified by
the following line in the security properties file:

</p><pre>    keystore.type=jks
</pre>

<p>To have the tools utilize a keystore implementation other
than the default, you can change that line to specify a different
keystore type.

</p><p>For example, if you have a provider package that supplies a
keystore implementation for a keystore type called "pkcs12",
change the line to

</p><pre>    keystore.type=pkcs12
</pre>

Note: case doesn't matter in keystore type designations. For example,
"JKS" would be considered the same as "jks".

</blockquote>

</li></ul>

<h3><a name="Certificates">Certificate</a></h3>

<blockquote>
A <b>certificate</b> (also known as a <b>public-key certificate</b>)
is a digitally signed statement from one entity (the <i>issuer</i>),
saying that the public key (and some other information)
of another entity (the <i>subject</i>) has some specific value.
</blockquote>

<ul>
<a name="CertificateTerms"></a>
<li><h4>Certificate Terms</h4>
<blockquote>

<p></p><dl><dt><i>Public Keys</i>
</dt><dd>
These are numbers associated with a particular entity, and
are intended to be known to everyone who needs to have trusted interactions
with that entity. Public keys are used to verify signatures.
</dd><dt><i>Digitally Signed</i>
</dt><dd>
If some data is <i>digitally signed</i> it has been stored with the
"identity" of an entity, and a signature that proves that entity knows about
the data. The data is rendered unforgeable by signing with the entity's
private key.
</dd><dt><i>Identity</i>
</dt><dd>
A known way of addressing an entity. In some systems the identity is
the public key, in others it can be anything from a Unix UID to an Email address
to an X.509 Distinguished Name.
</dd><dt><i>Signature</i>
</dt><dd>
A signature is computed over some data using the private key
of an entity (the <i>signer</i>, which in the case of a certificate is
also known as the <i>issuer</i>).
</dd><dt><i>Private Keys</i>
</dt><dd>
These are numbers, each of which is
supposed to be known only to the particular entity whose private
key it is (that is, it's supposed to be kept secret).
Private and public keys exist in pairs in all public key cryptography systems
(also referred to as "public key crypto systems").
In a typical public key crypto system,
such as DSA, a private key corresponds to exactly one public key.
Private keys are used to compute signatures.
</dd><dt><i>Entity</i>
</dt><dd>
An entity is a person, organization, program, computer, business,
bank, or something else you are trusting to some degree.
</dd></dl>

<p>
Basically, public key cryptography requires access to users' public keys.
In a large-scale networked environment it is impossible to guarantee that prior
relationships between communicating entities have been established or that a
trusted repository exists with all used public keys.
Certificates were invented as a solution to this public key distribution problem.
Now a <i>Certification Authority</i> (CA) can act as a
trusted third party.
CAs are entities (for example, businesses) that are trusted to sign (issue)
certificates for other entities. It is assumed that CAs will only create
valid and reliable certificates, as they are bound by legal agreements.
There are many public Certification Authorities, such as
<a href="http://www.verisign.com/">VeriSign</a>,
<a href="http://www.thawte.com/">Thawte</a>,
<a href="http://www.entrust.com/">Entrust</a>, and so on.
You can also run your own Certification Authority using products such as
the Netscape/Microsoft Certificate Servers or the Entrust CA product for
your organization.

</p><p>Using <b>keytool</b>, it is possible to display, import, and export
certificates. It is also possible to generate self-signed certificates.

</p><p><b>keytool</b> currently handles X.509 certificates.
</p></blockquote>

<a name="X509Cert"></a>
</li><li><h4>X.509 Certificates</h4>

<blockquote>

The X.509 standard defines what information can go into a certificate,
and describes how to write it down (the data format).
All the data in a certificate is encoded using two related
standards called ASN.1/DER.  <i>Abstract Syntax Notation 1</i> describes data.
The <i>Definite Encoding Rules</i> describe a single
way to store and transfer that data.

<p>All X.509 certificates have the following data, in addition
to the signature:

</p><dl><dt><i>Version</i>
</dt><dd>This identifies which version of the X.509 standard applies to
this certificate, which affects what information can be specified
in it. Thus far, three versions are defined.
<b>keytool</b> can import and export v1, v2, and v3
certificates. It generates v3 certificates.

<p>
<i>X.509 Version 1</i> has been available since 1988, is widely
deployed, and is the most generic.

</p><p><i>X.509 Version 2</i> introduced the concept of subject and issuer
unique identifiers to handle the possibility of reuse of
subject and/or issuer names over time. Most certificate profile
documents strongly recommend that names not be reused, and
that certificates should not make use of unique identifiers.
Version 2 certificates are not widely used.

</p><p><i>X.509 Version 3</i> is the most recent (1996) and supports the notion
of extensions, whereby anyone can define an extension and include
it in the certificate. Some common extensions in use today are:
<i>KeyUsage</i> (limits the use of the keys to particular
purposes such as "signing-only") and <i>AlternativeNames</i> (allows other
identities to also be associated with this public key, e.g. DNS names,
Email addresses, IP addresses). Extensions can be marked <i>critical</i>
to indicate that the extension should be checked and enforced/used.
For example, if a certificate has the KeyUsage extension marked
critical and set to "keyCertSign" then if this certificate is presented
during SSL communication, it should be rejected, as the certificate
extension indicates that the associated private key should only be used for
signing certificates and not for SSL use.
</p>

</dd><dt><i>Serial Number</i>
</dt><dd>The entity that created the certificate is responsible for
assigning it a serial number to distinguish it from other
certificates it issues.
This information is used in numerous ways, for example when a
certificate is revoked its serial number is placed in a Certificate
Revocation List (CRL).

<p></p></dd><dt><i>Signature Algorithm Identifier</i>
</dt><dd>This identifies the algorithm used by the CA to sign the certificate.

<p></p></dd><dt><i>Issuer Name</i>
</dt><dd>The <a href="#DName">X.500 Distinguished Name</a>
of the entity that signed the certificate.  This
is normally a CA.  Using this certificate implies trusting the
entity that signed this certificate.  (Note that in some cases,
such as <i>root or top-level</i> CA certificates, the issuer
signs its own certificate.)

<p></p></dd><dt><i>Validity Period</i>
</dt><dd>Each certificate is valid only for a limited amount of time.  This
period is described by a start date and time and an end date and time,
and can be as short as a few seconds or almost as long as a century.
The validity period chosen depends on a number of factors, such as the
strength of the private key used to sign the certificate or the amount
one is willing to pay for a certificate.
This is the expected period that entities can rely on the public value, if
the associated private key has not been compromised.

<p></p></dd><dt><i>Subject Name</i>
</dt><dd>The name of the entity whose public key the certificate identifies.
This name uses the X.500 standard, so it is intended to be
unique across the Internet. This is the
<a href="#DName">X.500 Distinguished Name</a> (DN) of
the entity, for example,
<pre>    CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</pre>
(These refer to the subject's Common Name, Organizational Unit,
Organization, and Country.)

<p></p></dd><dt><i>Subject Public Key Information</i>
</dt><dd>This is the public key of the entity being named, together with an
algorithm identifier which specifies which public key crypto system this key
belongs to and any associated key parameters.
</dd></dl>

</blockquote>


<a name="CertChains"></a>
</li><li><h4>Certificate Chains</h4>

<blockquote>

<p><b>keytool</b> can create and manage keystore "key" entries that
each contain a private key and an
associated certificate "chain". The first certificate in the chain
contains the public key corresponding to the private key.

</p><p>When keys are first generated (see the
<a href="#genkeypairCmd">-genkeypair</a> command), the chain starts off
containing a single element, a <i>self-signed certificate</i>.
A self-signed certificate is one for
which the issuer (signer) is the same as the subject (the entity
whose public key is being authenticated by the certificate).
Whenever the <code>-genkeypair</code> command is called to generate
a new public/private
key pair, it also wraps the public key into a self-signed
certificate.

</p><p>Later, after a Certificate Signing Request (CSR)
has been generated (see the <a href="#certreqCmd">-certreq</a> command)
and sent to a Certification Authority (CA),
the response from the CA is imported (see
<a href="#importCertCmd">-importcert</a>), and
the self-signed certificate is replaced by a chain
of certificates. At the bottom of the chain is the certificate
(reply) issued by the CA authenticating the subject's public key.
The next certificate
in the chain is one that authenticates the <i>CA</i>'s public key.

</p><p>In many cases, this is a self-signed certificate (that is,
a certificate from the CA authenticating its own public key)
and the last certificate in the chain.
In other cases, the CA may return a chain of certificates. In this case,
the bottom certificate in the chain is the same (a certificate
signed by the CA, authenticating the public key of the key
entry), but the second
certificate in the chain is a certificate signed by a <i>different</i>
CA, authenticating the public key of the CA you sent the CSR to.
Then, the next certificate in the chain will be a
certificate authenticating the second CA's key, and so on,
until a self-signed "root" certificate is reached.
Each certificate in the chain (after the first)
thus authenticates the public key of
the signer of the previous certificate in the chain.

</p><p>Many CAs only return the issued certificate,
with no supporting chain, especially when there is a flat hierarchy
(no intermediates CAs). In this case, the certificate
chain must be established
from trusted certificate information already stored in the
keystore.

</p><p>A different reply format (defined by the PKCS#7 standard) also
includes the supporting certificate chain, in addition to the
issued certificate. Both reply formats can be handled by <b>keytool</b>.

</p><p>The top-level (root) CA certificate is self-signed.
However, the trust into the root's public key does not come from
the root certificate itself (anybody could generate a self-signed
certificate with the distinguished name of say, the VeriSign root CA!),
but from other sources like a newspaper. The root CA public
key is widely known. The only reason it is stored in a certificate
is because this is the format understood by most tools, so the
certificate in this case is only used as a "vehicle" to transport
the root CA's public key. Before you add the root CA certificate
to your keystore, you should view it (using the
<code>-printcert</code> option) and compare
the displayed fingerprint with the well-known fingerprint (obtained
from a newspaper, the root CA's webpage, etc.).

</p></blockquote>

<a name="cacerts"></a>
</li><li><h4>The cacerts Certificates File</h4>

<blockquote>

<p>A certificates file named <b>"cacerts"</b> resides in the
security properties directory,
<code><i>java.home</i>\lib\security</code>, where <i>java.home</i> is
the runtime environment's directory  (the <tt>jre</tt> directory in the
SDK or the top-level directory of the Java 2 Runtime Environment).

</p><p>The "cacerts" file represents a
system-wide keystore with CA certificates. System administrators can
configure and manage that file using <b>keytool</b>, specifying "jks" as
the keystore type. The "cacerts" keystore file ships with several root CA
certificates with the following aliases and X.500 owner
distinguished names: </p><p>

</p>            <ul>
              <li><b>Alias</b>: thawtepersonalfreemailca<br />
              <b>Owner DN</b>:
              EmailAddress=personal-freemail@thawte.com,<br />
              CN=Thawte Personal Freemail CA,<br />
              OU=Certification Services Division,<br />
              O=Thawte Consulting, L=Cape Town, ST=Western Cape,
              C=ZA</li>

              <li><b>Alias</b>: thawtepersonalbasicca<br />
              <b>Owner DN</b>:
              EmailAddress=personal-basic@thawte.com,<br />
              CN=Thawte Personal Basic CA,<br />
              OU=Certification Services Division,<br />
              O=Thawte Consulting, L=Cape Town, ST=Western Cape,
              C=ZA</li>

              <li><b>Alias</b>: thawtepersonalpremiumca<br />
              <b>Owner DN</b>:
              EmailAddress=personal-premium@thawte.com,<br />
              CN=Thawte Personal Premium CA,<br />
              OU=Certification Services Division,<br />
              O=Thawte Consulting, L=Cape Town, ST=Western Cape,
              C=ZA</li>

              <li><b>Alias</b>: thawteserverca<br />
              <b>Owner DN</b>:
              EmailAddress=server-certs@thawte.com,<br />
              CN=Thawte Server CA, OU=Certification Services
              Division,<br />
              O=Thawte Consulting cc, L=Cape Town, ST=Western Cape,
              C=ZA</li>

              <li><b>Alias</b>: thawtepremiumserverca<br />
              <b>Owner DN</b>:
              EmailAddress=premium-server@thawte.com,<br />
              CN=Thawte Premium Server CA,<br />
              OU=Certification Services Division,<br />
              O=Thawte Consulting cc, L=Cape Town, ST=Western Cape,
              C=ZA</li>

              <li><b>Alias</b>: verisignclass1ca<br />
              <b>Owner DN</b>: OU=Class 1 Public Primary
              Certification Authority,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass2ca<br />
              <b>Owner DN</b>: OU=Class 2 Public Primary
              Certification Authority,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass3ca<br />
              <b>Owner DN</b>: OU=Class 3 Public Primary
              Certification Authority,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignserverca<br />
              <b>Owner DN</b>: OU=Secure Server Certification
              Authority,<br />
              O="RSA Data Security, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass1g2ca<br />
              <b>Owner DN</b>: OU=VeriSign Trust Network,<br />
              OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />
              OU=Class 1 Public Primary Certification Authority - G2,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass1g3ca<br />
              <b>Owner DN</b>: CN=VeriSign Class 1 Public Primary Certification Authority - G3,
              OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />
              OU=VeriSign Trust Network,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass2g2ca<br />
              <b>Owner DN</b>: OU=VeriSign Trust Network,<br />
              OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />
              OU=Class 2 Public Primary Certification Authority - G2,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass2g3ca<br />
              <b>Owner DN</b>: CN=VeriSign Class 2 Public Primary Certification Authority - G3,<br />
              OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />
              OU=VeriSign Trust Network,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass3g2ca<br />
              <b>Owner DN</b>: OU=VeriSign Trust Network,<br />
              OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />
              OU=Class 3 Public Primary Certification Authority - G2,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: verisignclass3g3ca<br />
              <b>Owner DN</b>: CN=VeriSign Class 3 Public Primary Certification Authority - G3,<br />
              OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />
              OU=VeriSign Trust Network,<br />
              O="VeriSign, Inc.", C=US</li>

              <li><b>Alias</b>: baltimorecodesigningca<br />
              <b>Owner DN</b>: CN=Baltimore CyberTrust Code Signing
              Root,<br />
              OU=CyberTrust, O=Baltimore, C=IE</li>

              <li><b>Alias</b>: gtecybertrustglobalca<br />
              <b>Owner DN</b>: CN=GTE CyberTrust Global Root,<br />
              OU="GTE CyberTrust Solutions, Inc.", O=GTE
              Corporation, C=US</li>

              <li><b>Alias</b>: baltimorecybertrustca<br />
              <b>Owner DN</b>: CN=Baltimore CyberTrust Root,<br />
              OU=CyberTrust, O=Baltimore, C=IE</li>

              <li><b>Alias</b>: gtecybertrust5ca<br />
              <b>Owner DN</b>: CN=GTE CyberTrust Root 5,<br />
              OU="GTE CyberTrust Solutions, Inc.", O=GTE
              Corporation, C=US</li>

              <li><b>Alias</b>: entrustclientca<br />
              <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br />
              OU=(c) 1999 Entrust.net Limited,<br />
              OU=www.entrust.net/Client_CA_Info/CPS incorp. by ref. limits liab.,<br />
              O=Entrust.net, C=US</li>

              <li><b>Alias</b>: entrustglobalclientca<br />
              <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br />
              OU=(c) 2000 Entrust.net Limited,<br />
              OU=www.entrust.net/GCCA_CPS incorp. by ref. (limits liab.),<br />
              O=Entrust.net</li>

              <li><b>Alias</b>: entrust2048ca<br />
              <b>Owner DN</b>: CN=Entrust.net Certification Authority (2048),<br />
              OU=(c) 1999 Entrust.net Limited,<br />
              OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.),<br />
              O=Entrust.net</li>

              <li><b>Alias</b>: entrustsslca<br />
              <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Authority,<br />
              OU=(c) 1999 Entrust.net Limited,<br />
              OU=www.entrust.net/CPS incorp. by ref. (limits liab.),<br />
              O=Entrust.net, C=US</li>

              <li><b>Alias</b>: entrustgsslca<br />
              <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Authority,<br />
              OU=(c) 2000 Entrust.net Limited,<br />
              OU=www.entrust.net/SSL_CPS incorp. by ref. (limits liab.),<br />
              O=Entrust.net</li>

              <li><b>Alias</b>: godaddyclass2ca<br />
              <b>Owner DN</b>: OU=Go Daddy Class 2 Certification Authority,<br />
              O="The Go Daddy Group, Inc.", C=US</li>

              <li><b>Alias</b>: starfieldclass2ca<br />
              <b>Owner DN</b>: OU=Starfield Class 2 Certification Authority,<br />
              O="Starfield Technologies, Inc.", C=US</li>

              <li><b>Alias</b>: valicertclass2ca<br />
              <b>Owner DN</b>: EMAILADDRESS=info@valicert.com,<br />
              CN=http://www.valicert.com/,<br />
              OU=ValiCert Class 2 Policy Validation Authority,<br />
              O="ValiCert, Inc.", L=ValiCert Validation Network</li>

              <li><b>Alias</b>: geotrustglobalca<br />
              <b>Owner DN</b>: CN=GeoTrust Global CA,<br />
              O=GeoTrust Inc., C=US</li>

              <li><b>Alias</b>: equifaxsecureca<br />
              <b>Owner DN</b>: OU=Equifax Secure Certificate Authority,<br />
              O=Equifax, C=US</li>

              <li><b>Alias</b>: equifaxsecureebusinessca1<br />
              <b>Owner DN</b>: CN=Equifax Secure eBusiness CA-1,<br />
              O=Equifax Secure Inc., C=US</li>

              <li><b>Alias</b>: equifaxsecureebusinessca2<br />
              <b>Owner DN</b>: OU=Equifax Secure eBusiness CA-2,<br />
              O=Equifax Secure, C=US</li>

              <li><b>Alias</b>: equifaxsecureglobalebusinessca1<br />
              <b>Owner DN</b>: CN=Equifax Secure Global eBusiness CA-1,<br />
              O=Equifax Secure Inc., C=US</li>

              <li><b>Alias</b>: soneraclass1ca<br />
              <b>Owner DN</b>: CN=Sonera Class1 CA, O=Sonera, C=FI</li>

              <li><b>Alias</b>: soneraclass2ca<br />
              <b>Owner DN</b>: CN=Sonera Class2 CA, O=Sonera, C=FI</li>

              <li><b>Alias</b>: comodoaaaca<br />
              <b>Owner DN</b>: CN=AAA Certificate Services,<br/>
              O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB</li>

              <li><b>Alias</b>: addtrustclass1ca<br />
              <b>Owner DN</b>: CN=AddTrust Class 1 CA Root,<br/>
              OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

              <li><b>Alias</b>: addtrustexternalca<br />
              <b>Owner DN</b>: CN=AddTrust External CA Root,<br/>
              OU=AddTrust External TTP Network, O=AddTrust AB, C=SE</li>

              <li><b>Alias</b>: addtrustqualifiedca<br />
              <b>Owner DN</b>: CN=AddTrust Qualified CA Root,<br/>
              OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

              <li><b>Alias</b>: utnuserfirsthardwareca<br />
              <b>Owner DN</b>: CN=UTN-USERFirst-Hardware,<br/>
              OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>
              L=Salt Lake City, ST=UT, C=US</li>

              <li><b>Alias</b>: utnuserfirstclientauthemailca<br />
              <b>Owner DN</b>: CN=UTN-USERFirst-Client Authentication and Email,<br/>
              OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>
              L=Salt Lake City, ST=UT, C=US</li>

              <li><b>Alias</b>: utndatacorpsgcca<br />
              <b>Owner DN</b>: CN=UTN - DATACorp SGC,<br/>
              OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>
              L=Salt Lake City, ST=UT, C=US</li>

              <li><b>Alias</b>: utnuserfirstobjectca<br />
              <b>Owner DN</b>: CN=UTN-USERFirst-Object,<br/>
              OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>
              L=Salt Lake City, ST=UT, C=US</li>
            </ul>


<p>The initial password of the "cacerts" keystore file is
"changeit". System administrators should change that password and the
default access permission of that file upon installing the SDK.


</p><blockquote>
<hr />
<b>IMPORTANT: Verify Your <code>cacerts</code> File</b>
<br />
Since you trust the CAs in the <code>cacerts</code>
file as entities for signing and issuing certificates to
other entities, you must manage the <code>cacerts</code> file carefully.
The <code>cacerts</code> file should contain only certificates of the
CAs you trust. It is your responsibility to
verify the trusted root CA certificates bundled
in the <code>cacerts</code> file and make your own trust
decisions. To remove an untrusted CA certificate
from the <code>cacerts</code> file, use the delete option of
the <code>keytool</code> command.
You can find the <code>cacerts</code> file in the JRE
installation directory. Contact your system administrator
if you do not have permission to edit this file.
<br />
<hr />
</blockquote>
</blockquote>


<a name="EncodeCertificate"></a>
</li><li><h4>The Internet RFC 1421 Certificate Encoding Standard</h4>

<blockquote>

<p>Certificates are often stored using the printable encoding format
defined by the Internet RFC 1421 standard, instead of their binary encoding.
This certificate format, also known as "Base 64 encoding",
facilitates exporting certificates to other applications
by email or through some other mechanism.

</p><p>Certificates read by the <code>-importcert</code> and
<code>-printcert</code> commands can be in either this format or
binary encoded.

</p><p>The <code>-exportcert</code> command
by default outputs a certificate in binary encoding, but will instead
output a certificate in the printable encoding format, if the
<code>-rfc</code> option is specified.

</p><p>The <code>-list</code> command by default prints the MD5 fingerprint
of a certificate. If the <code>-v</code> option is specified, the
certificate is printed in human-readable format, while if the
<code>-rfc</code> option is specified, the certificate is output
in the printable encoding format.

</p><p>In its printable encoding format, the encoded
certificate is bounded at the beginning by

</p><pre>-----BEGIN CERTIFICATE-----
</pre>

<p>and at the end by

</p><pre>-----END CERTIFICATE-----
</pre>

</blockquote>

</li></ul>

<a name="DName"></a>
<h3>X.500 Distinguished Names</h3>

<blockquote>

X.500 Distinguished Names are used to identify entities, such as those
which are named by the <code>subject</code> and <code>issuer</code> (signer)
fields of X.509 certificates. <b>keytool</b> supports
the following subparts:

<ul>

<li><i>commonName</i> - common name of a person, e.g., "Susan Jones"<p>

</p></li><li><i>organizationUnit</i> - small organization (e.g, department or
division) name, e.g., "Purchasing"<p>

</p></li><li><i>organizationName</i> - large organization name, e.g., "ABCSystems, Inc."<p>

</p></li><li><i>localityName</i> - locality (city) name, e.g., "Palo Alto"<p>

</p></li><li><i>stateName</i> - state or province name, e.g., "California"<p>

</p></li><li><i>country</i> - two-letter country code, e.g., "CH"<p>

</p></li></ul>

<p>When supplying a distinguished name string as the value of a
<code>-dname</code> option, as for the <code>-genkeypair</code> <!--or
<code>-selfcert</code--> command<!--s-->, the string must be in the following
format:

</p><pre>CN=<i>cName</i>, OU=<i>orgUnit</i>, O=<i>org</i>, L=<i>city</i>, S=<i>state</i>, C=<i>countryCode</i>
</pre>

<p>where all the italicized items represent actual values and
the above keywords are abbreviations for the following:

</p><pre>	CN=commonName
	OU=organizationUnit
	O=organizationName
	L=localityName
	S=stateName
	C=country
</pre>

<p>A sample distinguished name string is

</p><pre>CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino, S=California, C=US
</pre>

and a sample command using such a string is

<pre>keytool -genkeypair -dname "CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino,
S=California, C=US" -alias mark
</pre>

<p>Case does not matter for the keyword abbreviations. For example, "CN",
"cn", and "Cn" are all treated the same.

</p><p>Order matters; each subcomponent must appear in the designated
order. However, it is not necessary to have all the subcomponents.
You may use a subset, for example:

</p><pre>CN=Steve Meier, OU=SunSoft, O=Sun, C=US
</pre>

<p>If a distinguished name string value contains a comma, the
comma must be escaped by a "\" character when you specify the string
on a command line, as in

</p><pre>   cn=peter schuster, o=Sun Microsystems\, Inc., o=sun, c=us
</pre>

<p>It is never necessary to specify a distinguished name string
on a command line. If it is needed for a command, but not supplied
on the command line, the user is prompted for each of the
subcomponents. In this case, a comma does not need to be
escaped by a "\".
</p></blockquote>


<a name="TrustedCertWarning"></a>
<h3>WARNING Regarding Importing Trusted Certificates</h3>

<blockquote>

IMPORTANT: Be sure to check a certificate
very carefully before importing it as a trusted certificate!

<p>View it first (using the <code>-printcert</code> command, or the
<code>-importcert</code> command without the <code>-noprompt</code> option),
and make sure that the displayed certificate fingerprint(s) match the
expected ones. For example, suppose someone sends or emails you a
certificate, and you put it in a file named <code>C:\temp\cert</code>.
Before you consider adding the certificate to your list of
trusted certificates, you can execute a <code>-printcert</code> command
to view its fingerprints, as in

</p><pre>  keytool -printcert -file C:\temp\cert
    Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Serial Number: 59092b34
    Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
    Certificate Fingerprints:
         MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
         SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
</pre>

Then call or otherwise contact the person who sent the certificate,
and compare the fingerprint(s) that you see with the ones that they show.
Only if the fingerprints are equal is it guaranteed that
the certificate has not been replaced in transit with
somebody else's (for example, an attacker's) certificate.
If such an attack took place, and you did not check the certificate
before you imported it, you would end up trusting anything the
attacker has signed (for example, a JAR file with
malicious class files inside).

<p>Note: it is not required that you execute a <code>-printcert</code>
command prior to importing a certificate, since
before adding a certificate to the list of trusted certificates in the
keystore, the <code>-importcert</code> command prints out the certificate
information and prompts you to verify it. You then have the option of
aborting the import operation. Note, however, this is only the case if you
invoke the <code>-importcert</code> command without the
<code>-noprompt</code> option.
If the <code>-noprompt</code> option is given, there is no
interaction with the user.

</p></blockquote>


<a name="PasswordWarning"></a>
<h3>Warning Regarding Passwords</h3>

<blockquote>

<p>Most commands operating on a keystore require the store password.
Some commands require a private/secret key password.

</p><p>Passwords can be specified
on the command line (in the <code>-storepass</code> and
<code>-keypass</code> options,
respectively). However, a password should not be specified on a
command line or in a
script unless it is for testing purposes, or you are on a secure
system.

</p><p>If you don't specify a required password option on a
command line, you will be prompted for it.
</p></blockquote>


</blockquote>

<h2><a name="SeeAlso">SEE ALSO</a></h2>

<blockquote>

<ul>

<li><a href="jar.html">jar</a> tool documentation<p>

</p></li><li><a href="jarsigner.html">jarsigner</a> tool documentation<p>

</p></li><li>the
<a href="http://java.sun.com/docs/books/tutorial/security/index.html">
<b>Security</b></a> trail of the
<a href="http://java.sun.com/docs/books/tutorial/">
<b>Java Tutorial</b></a> for examples of the use of <b>keytool</b>

</li></ul>

</blockquote>


<h2><a name="Changes">CHANGES</a></h2>
<blockquote>
<p>The command interface for keytool changed in Java SE 6.</p>
<p><b>keytool</b> no longer displays password input when entered by users.
Since password input can no longer be viewed when entered,  users will
be prompted to re-enter passwords any time a password is being set or
changed (for example, when setting the initial keystore password, or
when changing a key password).</p>
<p>Some commands have simply been renamed, and other commands deemed obsolete
 are no longer listed in this document.  All previous commands (both renamed and obsolete)
 are still supported in this release and will continue to be supported in future releases.
 The following summarizes all of the changes made to the keytool command interface:
</p>
<p>Renamed commands:
</p><ul>
<li><code>-export</code>, renamed to <a href="#exportCertCmd"><code>-exportcert</code></a></li>
<li><code>-genkey</code>, renamed to <a href="#genkeypairCmd"><code>-genkeypair</code></a></li>
<li><code>-import</code>, renamed to <a href="#importCertCmd"><code>-importcert</code></a></li>
</ul>
<p>Commands deemed obsolete and no longer documented:
</p><ul>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#keycloneCmd">
<code>-keyclone</code></a></li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#identitydbCmd">
<code>-identitydb</code></a></li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#selfcertCmd">
<code>-selfcert</code></a></li>
</ul>
</blockquote>



<HR>
<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN="TOP"><TD><P><FONT SIZE="-2">
<A HREF=../../../legal/cpyr.html>Copyright &#169;</A> 1993, 2011, Oracle and/or its affiliates. All rights reserved.</FONT></P><FONT SIZE="-1"> Please send comments using this <a href=http://download.oracle.com/javase/feedback.html>Feedback</a> page.</FONT> </TD>
<TD ALIGN=RIGHT> <IMG SRC="../../../images/oraclelogo.gif" ALT="Oracle Corporation and/or its affiliates" BORDER=0 WIDTH=100 HEIGHT=29><BR>
<FONT SIZE="+1"> <i>Java Technology</i></FONT> </TD></TR>
</TABLE> 

<!-- STATIC FOOTER -->

</body></html>
