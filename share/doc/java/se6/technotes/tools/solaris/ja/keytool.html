<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="copyright" content="1998, 2010" />
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">

<title>keytool - 鍵と証明書の管理ツール</title>

<!-- base href="http://java.sun.com/j2se/1.6.0/docs/tooldocs/solaris/keytool.html" -->

<!-- **************** sandbox for notes *********************  From SEAN's email 7/26/06 paste this into the tiger doc:  Only keytool.html#cacerts (both Windows and Solaris) needs to be updated.  The following certificates should be added to that list (you can also cut-and-paste this out of the Mustang keytool.html#cacert section if it is easier):                <li><b>Alias</b>: verisignclass1g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />               OU=Class 1 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: verisignclass1g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 1 Public Primary Certification Authority - G3,               OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: verisignclass2g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />               OU=Class 2 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: verisignclass2g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 2 Public Primary Certification Authority - G3,<br />               OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: verisignclass3g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc. - For authorized use only",<br />               OU=Class 3 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: verisignclass3g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 3 Public Primary Certification Authority - G3,<br />               OU="(c) 1999 VeriSign, Inc. - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc.", C=US</li>                <li><b>Alias</b>: entrustclientca<br />               <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br  />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/Client_CA_Info/CPS incorp. by ref. limits liab. ,<br />               O=Entrust.net, C=US</li>                <li><b>Alias</b>: entrustglobalclientca<br />               <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br  />               OU=(c) 2000 Entrust.net Limited,<br />               OU=www.entrust.net/GCCA_CPS incorp. by ref. (limits liab.),<br />               O=Entrust.net</li>                <li><b>Alias</b>: entrust2048ca<br />               <b>Owner DN</b>: CN=Entrust.net Certification Authority (2048),<br  />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.),<br />               O=Entrust.net</li>                <li><b>Alias</b>: entrustsslca<br />               <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Author ity,<br />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/CPS incorp. by ref. (limits liab.),<br />               O=Entrust.net, C=US</li>                <li><b>Alias</b>: entrustgsslca<br />               <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Author ity,<br />               OU=(c) 2000 Entrust.net Limited,<br />               OU=www.entrust.net/SSL_CPS incorp. by ref. (limits liab.),<br />               O=Entrust.net</li>                <li><b>Alias</b>: godaddyclass2ca<br />               <b>Owner DN</b>: OU=Go Daddy Class 2 Certification Authority,<br / >               O="The Go Daddy Group, Inc.", C=US</li>                <li><b>Alias</b>: starfieldclass2ca<br />               <b>Owner DN</b>: OU=Starfield Class 2 Certification Authority,<br />               O="Starfield Technologies, Inc.", C=US</li>                <li><b>Alias</b>: valicertclass2ca<br />               <b>Owner DN</b>: EMAILADDRESS=info@valicert.com,<br />               CN=http://www.valicert.com/,<br />               OU=ValiCert Class 2 Policy Validation Authority,<br />               O="ValiCert, Inc.", L=ValiCert Validation Network</li>                <li><b>Alias</b>: geotrustglobalca<br />               <b>Owner DN</b>: CN=GeoTrust Global CA,<br />               O=GeoTrust Inc., C=US</li>                <li><b>Alias</b>: equifaxsecureca<br />               <b>Owner DN</b>: OU=Equifax Secure Certificate Authority,<br />               O=Equifax, C=US</li>                <li><b>Alias</b>: equifaxsecureebusinessca1<br />               <b>Owner DN</b>: CN=Equifax Secure eBusiness CA-1,<br />               O=Equifax Secure Inc., C=US</li>                <li><b>Alias</b>: equifaxsecureebusinessca2<br />               <b>Owner DN</b>: OU=Equifax Secure eBusiness CA-2,<br />               O=Equifax Secure, C=US</li>                <li><b>Alias</b>: equifaxsecureglobalebusinessca1<br />               <b>Owner DN</b>: CN=Equifax Secure Global eBusiness CA-1,<br />               O=Equifax Secure Inc., C=US</li>                <li><b>Alias</b>: soneraclass1ca<br />               <b>Owner DN</b>: CN=Sonera Class1 CA, O=Sonera, C=FI</li>                <li><b>Alias</b>: soneraclass2ca<br />               <b>Owner DN</b>: CN=Sonera Class2 CA, O=Sonera, C=FI</li>                <li><b>Alias</b>: comodoaaaca<br />               <b>Owner DN</b>: CN=AAA Certificate Services,<br/>               O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB</li>                <li><b>Alias</b>: addtrustclass1ca<br />               <b>Owner DN</b>: CN=AddTrust Class 1 CA Root,<br/>               OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: addtrustexternalca<br />               <b>Owner DN</b>: CN=AddTrust External CA Root,<br/>               OU=AddTrust External TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: addtrustqualifiedca<br />               <b>Owner DN</b>: CN=AddTrust Qualified CA Root,<br/>               OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: utnuserfirsthardwareca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Hardware,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utnuserfirstclientauthemailca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Client Authentication and Email, <br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utndatacorpsgcca<br />               <b>Owner DN</b>: CN=UTN - DATACorp SGC,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utnuserfirstobjectca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Object,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>        ********************************************************** -->
<link rel="stylesheet" href="../../../../technotes/css/guide.css" />
</head>

<body>
<!-- STATIC HEADER -->

<table width="100%"><tr><td valign="bottom" align="left"><img src="../../../../images/javalogo.gif"></td><td valign="bottom" align="right"><a href="../../../../index.html"><font size="-1">Documentation Contents</font></a></td></tr></table>
<h1>keytool - 鍵と証明書の管理ツール</h1>
<blockquote>
暗号化鍵、X.509 証明書チェーン、および信頼できる証明書を含むキーストア (データベース) を管理します。
</blockquote>

<h2>形式</h2>
<blockquote>
<pre><strong>keytool</strong> [ <a href="#Commands">commands</a> ]
</pre>
<p>
Java SE 6 で keytool のコマンドインタフェースが変更されました。 詳細については<a href="#Changes">「変更点」</a>の節を参照してください。以前に定義されたコマンドも引き続きサポートされています。
</p>
</blockquote>

<h2>説明</h2>

<blockquote>

<b>keytool</b> は、鍵と証明書を管理するためのユーティリティーです。keytool を使うと、自分の公開鍵と非公開鍵のペア、および関連する証明書を管理し、デジタル署名を使った自己認証 (ほかのユーザーまたはサービスに対して自分自身を認証すること) や、データの整合性と証明書に関するサービスを利用することができます。keytool では、通信相手の公開鍵を (証明書の形で) キャッシュすることもできます。

<p>「証明書」とは、あるエンティティー (人物、会社など) からのデジタル署名付きの文書のことです。 証明書には、ほかのあるエンティティーの公開鍵 (およびその他の情報) が特別な値を持っていることが書かれています<i></i>(<a href="#Certificates">「証明書」</a>を参照)。データにデジタル署名が付いている場合は、デジタル署名を検証することで、データの整合性およびデータが本物であることをチェックできます。データの「整合性」とは、データが変更されたり、改変されたりしていないことを意味します。 また、データが「本物である」とは、そのデータが、データを作成して署名したと称する人物から実際に渡されたデータであることを意味します。<i></i><i></i>

</p><p>また、<b>keytool</b> を使えば、DES などの対称暗号化/復号化で使用される秘密鍵を管理することもできます。

</p><p><b>keytool</b> は、鍵と証明書を<a href="#KeyStore"><i>「キーストア」</i></a>に格納します。

<!-- </p><p>The <a href="jarsigner.html"><b>jarsigner</b></a> tool uses information from a keystore to generate or verify digital signatures for Java ARchive (JAR) files. (A JAR file packages class files, images, sounds, and/or other digital data in a single file). <b>jarsigner</b> verifies the digital signature of a JAR file, using the certificate that comes with it (it is included in the signature block file of the JAR file), and then checks whether or not the public key of that certificate is "trusted", i.e., is contained in the specified keystore.  </p><p>The Java Runtime consults keystores to verify signatures on a signed JAR file when the JAR is first loaded.  Administrators can <a href="../../guides/security/PolicyFiles.html"> grant permissions</a> to different JAR files based on their respective signers. These permissions are then checked by the access control framework when code from the JAR file executes. -->

</p></blockquote>


<h2><a name="CommandNotes">コマンドとオプションに関する注</a></h2>

<blockquote>

<p><a href="#Commands">以下</a>では、コマンドとそのオプションについて説明します。注:

</p><ul>

<li>どのコマンド名およびオプション名にも先頭にマイナス記号 (-) が付く<p>

</p></li><li>各コマンドのオプションは任意の順序で指定できる<p>

</p></li><li>イタリック体になっていないすべての項目、または中括弧か角括弧で囲まれているすべての項目は、そのとおりに指定する必要がある<p>

</p></li><li>オプションを囲む中括弧は、一般に、そのオプションをコマンド行で指定しなかった場合に、<a href="#OptionDefaults">デフォルト値</a>が使われることを意味する。中括弧は、<code>-v</code>、<code>-rfc</code>、および <code>-J</code> オプションを囲むのにも使われるが、これらのオプションはコマンド行で指定された場合にのみ意味を持つ (つまり、これらのオプションには、オプション自体を指定しないこと以外に「デフォルト値」は存在しない)<p>

</p></li><li>オプションを囲む角括弧は、そのオプションをコマンド行で指定しなかった場合に、値の入力を求められることを意味する。ただし、<code>-keypass</code> オプションをコマンド行で指定しなかった場合は、<b>keytool</b> がキーストアのパスワードから非公開/秘密鍵の復元を試みる。 ユーザーは、この試みが失敗した場合に非公開/秘密鍵の入力を求められる<p>

</p></li><li>イタリック体の項目の実際の値 (オプションの値) は、ユーザーが指定する必要がある。たとえば、<code>-printcert</code> コマンドの形式は次のとおりである

<pre>  keytool -printcert {-file <i>cert_file</i>} {-v}
</pre>

<p><code>-printcert</code> コマンドを指定するときは、<i>cert_file</i> の代わりに実際のファイル名を指定する。次に例を示す

</p><pre>  keytool -printcert -file VScert.cer
</pre><p>

</p></li><li>オプションの値に空白 (スペース) が含まれている場合は、値を引用符で囲む必要がある<p>

</p></li><li><code>-help</code> コマンドはデフォルトのコマンドである。たとえば、次のようにコマンド行を指定したとする

<pre>  keytool
</pre>

これは、次のように指定することと同じである

<pre>  keytool -help
</pre>

</li></ul>


<h3><a name="OptionDefaults">オプションのデフォルト値</a></h3>

<blockquote>

オプションのデフォルト値は、次のとおりです。

<pre>-alias "mykey"

-keyalg
    "DSA" (<a href="#genkeypairCmd">-genkeypair</a> を使用している場合)
    "DES" (<a href="#genseckeyCmd">-genseckey</a> を使用している場合)

-keysize
    1024 (<a href="#genkeypairCmd">-genkeypair</a> を使用している場合)
    56 (<a href="#genseckeyCmd">-genseckey</a> を使用していて -keyalg が &quot;DES&quot; の場合)
    168 (<a href="#genseckeyCmd">-genseckey</a> を使用していて -keyalg が &quot;DESede&quot; の場合)

-validity 90

-keystore <i>ユーザーのホームディレクトリの <code>.keystore</code> というファイル</i>

-storetype <i>セキュリティープロパティーファイルの「keystore.type」プロパティーの値で、
           <code>java.security.KeyStore</code> の静的な <code>getDefaultType</code> メソッドから返される</i>

-file <i>読み込みの場合は標準入力、書き込みの場合は標準出力</i>

-protected false

</pre>

公開/非公開鍵ペアの生成において、署名アルゴリズム (<i>-sigalg</i> オプション) は、基になる非公開鍵のアルゴリズムから派生します。基になる非公開鍵が DSA タイプである場合、<i>-sigalg</i> オプションのデフォルト値は SHA1withDSA になり、基になる非公開鍵が RSA タイプである場合は、<i>-sigalg</i> オプションのデフォルト値は MD5withRSA になります。選択可能な <i>-keyalg</i> および <i>-sigalg</i> の完全な一覧については、<a href="../../guides/security/crypto/CryptoSpec.html#AppA">「Java Cryptography Architecture API Specification &amp; Reference」</a>を参照してください。

</blockquote>




<h3><a name="OptionsInAll">一般オプション</a></h3>

<blockquote>

<code>-v</code> オプションは、<code>-help</code> コマンドを除くすべてのコマンドで使用できます。このオプションを指定した場合、コマンドは「冗長」モードで実行され、詳細な証明書情報が出力されます。

<p>また、<code>-J<i>javaoption</i></code> オプションも、任意のコマンドで使用できます。このオプションを指定した場合、指定された <i>javaoption</i> 文字列が Java インタプリタに直接渡されます。このオプションには、空白を含めることはできません。このオプションは、実行環境またはメモリー使用を調整する場合に便利です。指定できるインタプリタオプションを一覧表示するには、コマンド行で <code>java -h</code> または <code>java -X</code> と入力してください。

</p><p>次のオプションは、キーストアに対する操作を行うすべてのコマンドで指定できます。

</p><dl><dt><code>-storetype <i>storetype</i></code>
</dt><dd>
この修飾子は、インスタンスを生成するキーストアのタイプを指定します。

<p></p></dd><dt><code>-keystore <i>keystore</i></code>
</dt><dd>
キーストアの場所を指定します。

<p> 特定の <b>keytool</b> コマンドを実行する際に、JKS <a href="#KeyStoreImplementation">ストアタイプ</a>が使用され、かつキーストアファイルがまだ存在していなかった場合、新しいキーストアファイルが作成されます。たとえば、<code>keytool -genkeypair</code> の実行時に <code>-keystore</code> オプションが指定されなかった場合、<code>.keystore</code> という名前のデフォルトキーストアファイルがユーザーのホームディレクトリ内にまだ存在していなければ、そこに作成されます。同様に、<code>-keystore <i>ks_file</i></code> というオプションが指定されてもその <i>ks_file</i> が存在しなかった場合、そのファイルが作成されます。

</p><p><code>-keystore</code> オプションからの入力ストリームは、<code>KeyStore.load</code> メソッドに渡されます。URL として <code>NONE</code> が指定されている場合は、null のストリームが <code>KeyStore.load</code> メソッドに渡されます。<code>NONE</code> は、<code>KeyStore</code> がファイルベースではなく、たとえば、ハードウェアトークンデバイスに置かれている場合に指定します。

</p></dd><dt><code>-storepass <i>storepass</i></code>
</dt><dd>
キーストアの整合性を保護するために使うパスワードを指定します。

<p><em>storepass</em> は、6 文字以上にする必要があります。指定したパスワードは、キーストアの内容にアクセスするすべてのコマンドで使われます。この種のコマンドを実行するときに、コマンド行で <code>-storepass</code> オプションを指定しなかった場合は、パスワードの入力を求められます。
</p><p>キーストアから情報を取り出す場合は、パスワードを省略できます。 パスワードを省略すると、取り出す情報の整合性をチェックできないので、警告が表示されます。
</p></dd><dt><code>-providerName <i>provider_name</i></code>
</dt><dd>
セキュリティープロパティーファイル内に含まれる暗号化サービスプロバイダ名を特定するために使用されます。<p></p>

<p></p></dd><dt><code>-providerClass <i>provider_class_name</i></code>
</dt><dd>暗号化サービスプロバイダがセキュリティープロパティーファイルに指定されていないときは、そのマスタークラスファイルの名前を指定するときに使われます。<p>

</p></dd><dt><code>-providerArg <i>provider_arg</i></code>
</dt><dd>
<code>-providerClass</code> と組み合わせて使用します。<i>provider_class_name</i> のコンストラクタに対する省略可能な文字列入力引数を表します。<p></p>

<p></p></dd><dt><code>-protected</code>
</dt><dd>
<code>true</code> または <code>false</code> のいずれか。専用 PIN リーダーなどの保護された認証パスを介してパスワードを指定する必要がある場合には、この値に <code>true</code> を指定してください。
<p></p></dd></dl>

</blockquote>



</blockquote>

<h2><a name="Commands">コマンド</a></h2>

<blockquote>

<h3>キーストアへのデータの作成または追加</h3>

<blockquote>

<dl>

<dt><code><b><font size="+1"><a name="genkeypairCmd">-genkeypair </a></font></b> {-alias <i>alias</i>} {-keyalg <i>keyalg</i>} {-keysize <i>keysize</i>} {-sigalg <i>sigalg</i>} [-dname <i>dname</i>] [-keypass <i>keypass</i>] {-validity <i>valDays</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>鍵のペア (公開鍵および関連する非公開鍵) を生成します。公開鍵は X.509 v3 自己署名証明書でラップされます。 証明書は、単一の要素を持つ証明書チェーンとして格納されます。この証明書チェーンと非公開鍵は、<em>alias</em> で特定される新しいキーストアエントリに格納されます。

</p><p><em>keyalg</em> には、鍵のペアを生成するのに使うアルゴリズムを指定し、<em>keysize</em> には、生成する各鍵のサイズを指定します。 <em>sigalg</em> には、自己署名証明書に署名を付けるときに使うアルゴリズムを指定します。このアルゴリズムは、<em>keyalg</em> と互換性のあるものでなければなりません。

</p><p><em>dname</em> には、<em>alias</em> に関連付け、自己署名証明書の <code>issuer</code> フィールドと <code>subject</code> フィールドとして使う <a href="#DName">X.500 識別名</a>を指定します。コマンド行で識別名を指定しなかった場合は、識別名の入力を求められます。

</p><p><em>keypass</em> には、生成される鍵のペアのうち、非公開鍵を保護するのに使うパスワードを指定します。パスワードを指定しなかった場合、ユーザーはその入力求められます。このとき、Return キーを押すと、キーストアのパスワードと同じパスワードが鍵のパスワードに設定されます。 <em>keypass</em> は、6 文字以上でなければなりません。

</p><p><em>valDays</em> には、証明書の有効日数を指定します。</p>
<p>このコマンドは、以前のリリースでは <tt>-genkey</tt> という名前でした。この古い名前は、このリリースでも引き続きサポートされており、今後のリリースでもサポートされる予定です。ただし、今後はわかりやすいように、新しい名前 <tt>-genkeypair</tt> を使用することをお勧めします。 </p>
</dd>

<dt><code><b><font size="+1"><a name="genseckeyCmd">-genseckey </a></font></b> {-alias <i>alias</i>} {-keyalg <i>keyalg</i>} {-keysize <i>keysize</i>} [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>秘密鍵を生成し、それを <em>alias</em> で特定される新しい <code>KeyStore.SecretKeyEntry</code> 内に格納します。
</p><p>
<em>keyalg</em> は秘密鍵の生成に使用するアルゴリズムを、<em>keysize</em> は生成する鍵のサイズを、それぞれ指定します。<em>keypass</em> は秘密鍵の保護に使用するパスワードです。パスワードを指定しなかった場合、ユーザーはその入力求められます。このとき、Return キーを押すと、キーストアのパスワードと同じパスワードが鍵のパスワードに設定されます。 <em>keypass</em> は、6 文字以上でなければなりません。
</p></dd>

<dt><code><b><font size="+1"><a name="importCertCmd">-importcert</a></font></b> {-alias <i>alias</i>} {-file <i>cert_file</i>} [-keypass <i>keypass</i>] {-noprompt} {-trustcacerts} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>ファイル <i>cert_file</i> から証明書または証明書チェーン (証明書チェーンの場合は、PKCS#7 形式の応答で提供されるもの) を読み込み、<i>alias</i> によって特定されるキーストアエントリに格納します。ファイルが指定されていない場合は、標準入力から証明書または PKCS#7 応答を読み込みます。

</p><p><b>keytool</b> では、X.509 v1、v2、v3 の証明書、および、PKCS#7 形式の証明書から構成されている PKCS#7 形式の証明書チェーンをインポートできます。インポートするデータは、バイナリ符号化方式、または出力可能符号化方式 (Base64 符号化とも呼ばれる) のどちらかで提供する必要があります。 出力可能符号化方式は、<a href="#EncodeCertificate">インターネット RFC 1421 証明書符号化規格</a>で定義されています。この符号化方式の場合、証明書は「-----BEGIN」で始まる文字列で開始され、「-----END」で始まる文字列で終了しなければなりません。

</p><p>証明書のインポートには、次の 2 つの目的があります。 </p><p>

</p><ol>

<li>信頼できる証明書のリストに証明書を追加する<p>
</p></li><li>CA に証明書署名要求 (<a href="#certreqCmd">-certreq</a> コマンドを参照) を送信した結果として、CA から受け取った証明応答をインポートする

</li></ol>

<p> どちらの種類のインポートを行うかは、<code>-alias</code> オプションの値によって指定します。

</p><ol>

<p></p><li><b>別名がキーエントリをポイントしない場合</b>、<b>keytool</b> はユーザーが信頼できる証明書エントリを追加しようとしているものと見なします。この場合、別名がキーストア内にすでに存在していてはいけません。別名がすでに存在している場合、その別名の信頼できる証明書がすでに存在することになるので、<b>keytool</b> はエラーを出力し、証明書のインポートを行いません。
<p>

</p></li><li><b>別名がキーエントリをポイントしない場合</b>、<b>keytool</b> はユーザーが信頼できる証明書エントリを追加しようとしているものと見なします。

</li></ol>

<h4>新しい信頼できる証明書のインポート</h4>

<blockquote>

<p><b>keytool</b> は、キーストアに証明書を追加する前に、キーストア内にすでに存在する信頼できる証明書を使って、インポートする証明書から (ルート CA の) 自己署名証明書に至るまでの信頼のチェーンの構築を試みます。

</p><p><code>-trustcacerts</code> オプションを指定した場合、追加の証明書は信頼できるすなわち <a href="#cacerts">cacerts という名前のファイル</a>に含まれる証明書のチェーンと見なされます。

</p><p><b>keytool</b> が、インポートする証明書から自己署名証明書 (キーストアまたは cacerts ファイルに含まれている自己署名証明書) に至るまでの信頼のパスの構築に失敗した場合は、インポートする証明書の情報を表示し、ユーザーに確認を求めます。 この場合は、表示された証明書のフィンガープリントと、ほかのなんらかの (信頼できる) 情報源 (証明書の所有者本人など) から入手したフィンガープリントとを比較します。「信頼できる証明書」として証明書をインポートするときは、証明書が有効であることを慎重に確認する必要があります。詳細は、<a href="#TrustedCertWarning">「信頼できる証明書のインポートに関する注意事項」</a>を参照してください。インポート操作は、証明書を確認する時点で中止できます。ただし、<code>-noprompt</code> オプションが指定されている場合、ユーザーとの対話は行われません。

</p></blockquote>


<h4>証明応答のインポート</h4>

<blockquote>

<p>「証明応答」をインポートするときは、キーストア内の信頼できる証明書、および (<code>-trustcacerts</code> オプションが指定されている場合は) <a href="#cacerts">cacerts キーストアファイル</a>で構成された証明書を使って証明応答が検査されます。

</p><p>証明応答が信頼できるかどうかを決定する方法は次のとおりです。 </p><p>

</p><ul>

<li><b>証明応答が単一の X.509 証明書である場合</b>、<b>keytool</b> は、証明応答から (ルート CA の) 自己署名証明書に至るまでの信頼チェーンの確立を試みます。証明応答と、証明応答の認証に使われる証明書の階層構造は、<i>alias</i> の新しい証明書チェーンを形成します。信頼チェーンが確立されない場合、証明応答はインポートされません。この場合、<b>keytool</b> は証明書を出力せず、ユーザーに検証を求めるプロンプトを表示します。 ユーザーが証明応答の信頼性を判断するのは、不可能ではなくても非常に困難だからです。 <p>

</p></li><li><b>証明応答が PKCS#7 形式の証明書チェーンである場合</b>、<b>keytool</b> は、まずチェーンを並べ替えて、ユーザーの証明書が最初に、ルート CA の自己署名証明書が最後にくるようにしたあと、証明応答に含まれるルート CA の証明書と、キーストア内または (<code>-trustcacerts</code> オプションが指定されている場合は) cacerts キーストアファイル内の信頼できる証明書とをすべて比較し、一致するものがあるかどうかを調べます。一致するものが見つからなかった場合は、ルート CA の証明書の情報を表示し、ユーザーに確認を求めます。 この場合は、表示された証明書のフィンガープリントと、ほかのなんらかの (信頼できる) 情報源 (ルート CA 自身など) から入手したフィンガープリントとを比較します。インポート操作は、証明書を確認する時点で中止できます。ただし、<code>-noprompt</code> オプションが指定されている場合、ユーザーとの対話は行われません。

</li></ul>

<p> 証明書応答内の公開鍵が <i>alias</i> の下にすでに格納されているユーザーの公開鍵に一致した場合、古い証明書チェーンが応答内の新しい証明書チェーンで置き換えられます。以前の証明書チェーンを新しい証明書チェーンで置き換えることができるのは、有効な <i>keypass</i>、つまり該当するエントリの非公開鍵を保護するためのパスワードを指定した場合だけです。パスワードを指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。

</p></blockquote>
<p></p>
<p>このコマンドは、以前のリリースでは <tt>-import</tt> という名前でした。この古い名前は、このリリースでも引き続きサポートされており、今後のリリースでもサポートされる予定です。ただし、今後はわかりやすいように、新しい名前 <tt>-importcert</tt> を使用することをお勧めします。 </p>
</dd>

<!--dt><code><b><font size="+1"><a name="selfcertCmd">-selfcert </a></font></b>   {-alias <i>alias</i>}   {-sigalg <i>sigalg</i>} {-dname <i>dname</i>}   {-validity <i>valDays</i>} [-keypass <i>keypass</i>]   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Generates an X.509 v3 self-signed certificate, using keystore information including the private key and public key associated with <em>alias</em>. If <i>dname</i> is supplied at the command line, it is used as the <a href="#DName">X.500 Distinguished Name</a> for both the <code>issuer</code> and <code>subject</code> of the certificate. Otherwise, the X.500 Distinguished Name associated with <em>alias</em> (at the bottom of its existing certificate chain) is used.  </p><p>The generated certificate is stored as a single-element certificate chain in the keystore entry identified by <em>alias</em>, where it replaces the existing certificate chain.  </p><p><em>sigalg</em> specifies the algorithm that should be used to sign the certificate.  </p><p>In order to access the private key, the appropriate password must be provided, since private keys are protected in the keystore with a password. If <em>keypass</em> is not provided at the command line, and is different from the password used to protect the integrity of the keystore, the user is prompted for it.  </p><p><em>valDays</em> tells the number of days for which the certificate should be considered valid.</p><p>   </p></dd--> <!--dt><code><b><font size="+1"><a name="identitydbCmd">-identitydb </a></font></b>   {-file <i>idb_file</i>}   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Reads the JDK 1.1.x-style identity database from the file <em>idb_file</em>, and adds its entries to the keystore. If no file is given, the identity database is read from stdin. If a keystore does not exist, it is created.  </p><p>Only identity database entries ("identities") that were marked as trusted will be imported in the keystore. All other identities will be ignored. For each trusted identity, a keystore entry will be created. The identity's name is used as the "alias" for the keystore entry.  </p><p>The private keys from trusted identities will all be encrypted under the same password, <i>storepass</i>. This is the same password that is used to protect the keystore's integrity. Users can later assign individual passwords to those private keys by using the "-keypasswd" <b>keytool</b> command option.  </p><p>An identity in an identity database may hold more than one certificate, each certifying the same public key. But a keystore key entry for a private key has that private key and a single "certificate chain" (initially just a single certificate), where the first certificate in the chain contains the public key corresponding to the private key. When importing the information from an identity, only the first certificate of the identity is stored in the keystore. This is because an identity's name in an identity database is used as the alias for its corresponding keystore entry, and alias names are unique within a keystore,   </p></dd-->
<dt><code><b><font size="+1"><a name="importKeyStoreCmd">-importkeystore </a></font></b> -srckeystore <i>srckeystore</i> -destkeystore <i>destkeystore</i> {-srcstoretype <i>srcstoretype</i>} {-deststoretype <i>deststoretype</i>} [-srcstorepass <i>srcstorepass</i>] [-deststorepass <i>deststorepass</i>] {-srcprotected} {-destprotected} {-srcalias <i>srcalias</i> {-destalias <i>destalias</i>} [-srckeypass <i>srckeypass</i>] [-destkeypass <i>destkeypass</i>] } {-noprompt} {-srcProviderName <i>src_provider_name</i>} {-destProviderName <i>dest_provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
ソースキーストアからターゲットキーストアへ、単一のエントリまたはすべてのエントリをインポートします。
</p><p>
<em>srcalias</em> オプションが指定された場合、このコマンドは、その別名で特定される単一のエントリをターゲットキーストアにインポートします。<em>destalias</em> 経由でターゲット別名が指定されなかった場合、<em>srcalias</em> がターゲット別名として使用されます。ソースのエントリがパスワードで保護されていた場合、<em>srckeypass</em> を使ってそのエントリが回復されます。<em>srckeypass</em> が指定されなかった場合、<b>keytool</b> は <em>srcstorepass</em> を使ってそのエントリを回復しようとします。<em>srcstorepass</em> が指定されなかったか正しくなかった場合、ユーザーはパスワードの入力を求められます。ターゲットエントリは <em>destkeypass</em> によって保護されます。<em>destkeypass</em> が指定されなかった場合、ターゲットエントリはソースエントリのパスワードによって保護されます。
</p><p>
<em>srcalias</em> オプションが指定されなかった場合、ソースキーストア内のすべてのエントリがターゲットキーストア内にインポートされます。各ターゲットエントリは対応するソースエントリの別名の下に格納されます。ソースのエントリがパスワードで保護されていた場合、<em>srcstorepass</em> を使ってそのエントリが回復されます。<em>srcstorepass</em> が指定されなかったか正しくなかった場合、ユーザーはパスワードの入力を求められます。ソースキーストア内のあるエントリタイプがターゲットキーストアでサポートされていない場合や、あるエントリをターゲットキーストアに格納する際にエラーが発生した場合、ユーザーはそのエントリをスキップして処理を続行するか、あるいは処理を中断するかの選択を求められます。ターゲットエントリはソースエントリのパスワードによって保護されます。
</p><p>
ターゲット別名がターゲットキーストア内にすでに存在していた場合、ユーザーは、そのエントリを上書きするか、あるいは異なる別名の下で新しいエントリを作成するかの選択を求められます。
</p><p>
<code>-noprompt</code> を指定した場合、ユーザーは新しいターゲット別名の入力を求められません。既存のエントリはそのターゲット別名で自動的に上書きされます。最後に、インポートできないエントリは自動的にスキップされ、警告が出力されます。
</p>

<p></p>

      </dd>
    </dl>


</blockquote>



<h3>データのエクスポート</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="certreqCmd">-certreq </a></font></b>{-alias <i>alias</i>} {-sigalg <i>sigalg</i>} {-file <i>certreq_file</i>} [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>PKCS#10 形式を使って証明書署名要求 (CSR) を生成します。

</p><p>CSR は、証明書発行局 (CA) に送信することを目的としたものです。CA は、証明書要求者を (通常はオフラインで) 認証し、証明書または証明書チェーンを送り返します。 この証明書または証明書チェーンは、キーストア内の既存の証明書チェーン (最初は 1 つの自己署名証明書から構成される) に置き換えて使います。

</p><p><em>alias</em> に関連付けられた非公開鍵と X.500 識別名は、PKCS#10 証明書要求を作成するのに使われます。非公開鍵はキーストア内ではパスワードによって保護されているので、非公開鍵にアクセスするには、適切なパスワードを提供する必要があります。コマンド行で <em>keypass</em> を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。</p>

<p><em>sigalg</em> には、CSR に署名を付けるときに使うアルゴリズムを指定します。

</p><p>CSR は、ファイル <em>certreq_file</em> に格納されます。ファイルが指定されていない場合は、標準出力に CSR が出力されます。

</p><p>CA からの応答をインポートするには、<em>importcert</em> コマンドを使います。</p><p>


</p></dd><dt><code><b><font size="+1"><a name="exportCertCmd">-exportcert</a></font></b> {-alias <i>alias</i>} {-file <i>cert_file</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-rfc} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> に関連付けられた証明書を (キーストアから) 読み込み、ファイル <em>cert_file</em> に格納します。

</p><p>ファイルが指定されていない場合は、標準出力に証明書が出力されます。

</p><p>デフォルトでは、バイナリ符号化方式の証明書が出力されます。 ただし、<code>-rfc</code> オプションを指定した場合は、出力可能符号化方式の証明書が出力されます。 出力可能符号化方式は、<a href="#EncodeCertificate">インターネット RFC 1421 証明書符号化規格</a>で定義されています。

</p><p><i>alias</i> が、信頼できる証明書を参照している場合は、該当する証明書が出力されます。それ以外の場合、<i>alias</i> は、関連付けられた証明書チェーンを持つ鍵エントリを参照します。この場合は、チェーン内の最初の証明書が返されます。この証明書は、<i>alias</i> によって表されるエンティティーの公開鍵を認証する証明書です。</p><p>

</p>
<p>このコマンドは、以前のリリースでは <tt>-export</tt> という名前でした。この古い名前は、このリリースでも引き続きサポートされており、今後のリリースでもサポートされる予定です。ただし、今後はわかりやすいように、新しい名前 <tt>-exportcert</tt> を使用することをお勧めします。 </p>
</dd></dl>

</blockquote>


<h3>データの表示</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="listCmd">-list </a></font></b> {-alias <i>alias</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v | -rfc} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><i>alias</i> で特定されるキーストアエントリの内容を (標準出力に) 出力します。別名が指定されていない場合は、キーストア全体の内容が表示されます。

</p><p>このコマンドは、デフォルトでは証明書の MD5 フィンガープリントを表示します。<code>-v</code> オプションが指定されている場合は、所有者、発行者、シリアル番号、拡張機能などの付加的な情報とともに、人間が読むことのできる形式で証明書が表示されます。<code>-rfc</code> オプションが指定されている場合は、出力可能符号化方式で証明書の内容が表示されます。 出力可能符号化方式は、<a href="#EncodeCertificate">インターネット RFC 1421 証明書符号化規格</a>で定義されています。

</p><p><code>-v</code> オプションと <code>-rfc</code> オプションとを同時に指定することはできません。
</p><p></p></dd>

<dt><code><b><font size="+1"><a name="printcertCmd">-printcert </a></font><a name="printcertCmd"></a></b> <a name="printcertCmd">  {-file <i>cert_file</i>} {-v} {-J<i>javaoption</i>}</a></code>
</dt><dd>
<p>ファイル <a name="printcertCmd"><em>cert_file</em> から証明書を読み込み、人間が読むことのできる形式で証明書の内容を表示します。ファイルが指定されていない場合は、標準入力から証明書を読み込みます。

</a></p><p><a name="printcertCmd">証明書は、バイナリ符号化方式または出力可能符号化方式で表示できます。出力可能符号化方式は、</a><a href="#EncodeCertificate">インターネット RFC 1421 証明書符号化規格</a>で定義されています。

</p><p>注:このコマンドはキーストアとは関係なく動作します。</p><p>


</p></dd>

</dl>

</blockquote>


<h3>キーストアの管理</h3>

<blockquote>

<dl>
<!--dt><code><b><font size="+1"><a name="keycloneCmd">-keyclone </a></font></b>   {-alias <i>alias</i>}   [-dest <i>dest_alias</i>]   [-keypass <i>keypass</i>] [-new <i>new_keypass</i>]   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Creates a new keystore entry, which has the same private key and certificate chain as the original entry if it's a private key entry, or has the same secret key if it's a secret key entry.  </p><p>The original entry is identified by <em>alias</em> (which defaults to "mykey" if not provided). The new (destination) entry is identified by <em>dest_alias</em>. If no destination alias is supplied at the command line, the user is prompted for it.  </p><p>If the private/secret key password is different from the keystore password, then the entry will only be cloned if a valid <i>keypass</i> is supplied.  This is the password used to protect the key associated with <i>alias</i>. If no key password is supplied at the command line, and the key password is different from the keystore password, the user is prompted for it.  The key in the cloned entry may be protected with a different password, if desired. If no <code>-new</code> option is supplied at the command line, the user is prompted for the new entry's password (and may choose to let it be the same as for the cloned entry's private/secret key).  </p></dd-->
<dt><code><b><font size="+1"><a name="storePasswdCmd">-storepasswd</a> </font></b>[-new <i>new_storepass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>キーストアの内容の整合性を保護するために使うパスワードを変更します。<em>new_storepass</em> には、新しいパスワードを指定します。 <em>new_storepass</em> は、6 文字以上でなければなりません。</p>

<p>


</p></dd><dt><code><b><font size="+1"><a name="keyPasswdCmd">-keypasswd</a> </font></b>{-alias <i>alias</i>} [-keypass <i>old_keypass</i>] [-new <i>new_keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> によって特定される非公開/秘密鍵を保護するためのパスワードを、<em>old_keypass</em> から <em>new_keypass</em> に変更します。 <em>new_keypass</em> は、6 文字以上でなければなりません。

</p><p>コマンド行で <code>-keypass</code> オプションを指定しておらず、鍵のパスワードがキーストアのパスワードと異なる場合は、鍵のパスワードの入力を求められます。

</p><p>コマンド行で <code>-new</code> オプションを指定しなかった場合は、新しいパスワードの入力を求められます。</p><p>

</p><p>


</p></dd><dt><code><b><font size="+1"><a name="deleteCmd">-delete </a></font></b> [-alias <i>alias</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> によって特定されるエントリをキーストアから削除します。コマンド行で別名を指定しなかった場合は、別名の入力を求められます。</p><p>

</p></dd>
<dt><code><b><font size="+1"><a name="changeAliasCmd">-changealias</a> </font></b> {-alias <i>alias</i>} [-destalias <i>destalias</i>] [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
指定された <em>alias</em> から新しい別名 <em>destalias</em> へ、既存のキーストアエントリを移動します。ターゲット別名が指定されなかった場合、このコマンドはその入力を求めます。元のエントリがエントリパスワードで保護されていた場合、「-keypass」オプション経由でそのパスワードを指定できます。鍵パスワードが指定されなかった場合、<i>storepass</i> (指定された場合) がまず試みられます。その試みが失敗すると、ユーザーはパスワードの入力を求められます。
</p></dd>
</dl>
</blockquote>


<h3>ヘルプの表示</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="helpCmd">-help</a> </font></b></code>
</dt><dd>
<p>基本的なコマンドとそのオプションの一覧を表示します。</p><p>


</p></dd>

</dl>

</blockquote>


</blockquote>





<h2><a name="EXAMPLES">例</a></h2>

<blockquote>

<p>ここでは、自分の鍵のペアおよび信頼できるエンティティーからの証明書を管理するためのキーストアを作成する場合を例として示します。

</p>
<!--h3>Generating a Secret Key</h3>  <blockquote> <p>You can always generate a secret key in a keystore so that it can be used by a Java program later. The command is very simple:  </p><pre>    keytool -genseckey -alias mysecret -keyalg DESede -keysize 112
      -keypass 426593 -keystore /working/mykeystore -storepass ab987c
</pre>  <p>This command create a DESede type secret key (with key size 112) in a keystore based on the file /working/mykeystore. The storepass ab987c is needed to update the keystore. The keypass 426593 is the protect password for the secret entry itself. When the secret key is generated, it is stored as a KeyStore.SecretKeyEntry in the key store which you can always use KeyStore.getKey() to retrieve.  </p><p>in order to see what kind of secret key you can create, you can refer to <a href="../../guides/security/crypto/CryptoSpec.html#AppA"> http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</a> to see what keyalg you can provide. Please take attention that although the above link is titled SunJCE Default keysizes, that does not garantee keytool will recognize it, you are still required to provide the keysize option yourself. </p></blockquote>  </p-->

<h3>鍵のペアの生成</h3>

<blockquote>

<p>まず、キーストアを作成して鍵のペアを生成する必要があります。次に示すのは、実行するコマンドの例です。

</p><pre>    keytool -genkeypair -dname "cn=Mark Jones, ou=JavaSoft, o=Sun, c=US"
      -alias business -keypass kpi135 -keystore /working/mykeystore
      -storepass ab987c -validity 180
</pre>

<p>注:このコマンドは 1 行に入力しなければなりません。例で複数行に入力しているのは読みやすくするためです。

</p><p>この例では、working ディレクトリに mykeystore という名前のキーストアを作成し (キーストアはまだ存在していないと仮定する)、作成したキーストアにパスワード ab987c を割り当てます。生成する公開鍵と非公開鍵のペアに対応するエンティティーの「識別名」は、通称が「Mark Jones」、組織単位が「JavaSoft」、組織が「Sun」、2 文字の国番号が「US」です。公開鍵と非公開鍵のサイズはどちらも 1024 ビットで、鍵の作成にはデフォルトの DSA 鍵生成アルゴリズムを使用します。

</p><p>このコマンドは、公開鍵と識別名情報を含む自己署名証明書 (デフォルトの SHA1withDSA 署名アルゴリズムを使用) を作成します。証明書の有効期間は 180 日です。 証明書は、別名「business」で特定されるキーストアエントリ内の非公開鍵に関連付けられます。非公開鍵にはパスワード「kpi135」が割り当てられます。

</p><p>オプションのデフォルト値を使う場合は、上に示したコマンドを大幅に短くすることができます。実際には、オプションを 1 つも指定せずにコマンドを実行することも可能です。 デフォルト値を持つオプションでは、オプションを指定しなければデフォルト値が使われ、必要な値については入力を求められます。たとえば、単に次のように入力することもできます。

</p><pre>    keytool -genkeypair
</pre>

この場合は、mykey という別名でキーストアエントリが作成され、新しく生成された鍵のペア、および 90 日間有効な証明書がこのエントリに格納されます。このエントリは、ホームディレクトリ内の .keystore という名前のキーストアに置かれます。このキーストアがまだ存在していない場合は、作成されます。識別名情報、キーストアのパスワード、および非公開鍵のパスワードについては、入力を求められます。

<p>以下では、オプションを指定しないで <code>-genkeypair</code> コマンドを実行したものとして例を示します。 情報の入力を求められた場合は、最初に示した <code>-genkeypair</code> コマンドの値を入力したものとします (たとえば、非公開鍵のパスワードには kpi135 と指定)。

</p></blockquote>


<h3>証明書発行局に対する署名付き証明書の要求</h3>

<blockquote>

<p>現時点で手元にあるのは、1 通の自己署名証明書だけです。証明書に証明書発行局 (CA) の署名が付いていれば、ほかのユーザーから証明書が信頼できる可能性も高くなります。CA の署名を取得するには、まず、証明書署名要求 (CSR) を生成します。 たとえば、次のようにします。

</p><pre>    keytool -certreq -file MarkJ.csr
</pre>

CSR (デフォルト別名「mykey」によって特定されるエンティティーの CSR) が作成され、MarkJ.csr という名前のファイルに置かれます。このファイルは、VeriSign などの CA に提出します。 CA は要求者を (通常はオフラインで) 認証し、要求者の公開鍵を認証した署名付きの証明書を送り返します。場合によっては、CA が証明書のチェーンを返すこともあります。 証明書のチェーンでは、各証明書がチェーン内のその前の署名者の公開鍵を認証します。

</blockquote>


<h3>CA からの証明書のインポート</h3>

<blockquote>

<p>作成した自己署名証明書は、証明書チェーンで置き換える必要があります。 証明書チェーンでは、各証明書が、「ルート」CA を起点とするチェーン内の次の証明書の署名者の公開鍵を認証します。

</p><p>CA からの証明応答をインポートするには、キーストアか、(<a href="#importCertCmd">importcert コマンド</a> で説明しているように) <code>cacerts</code> キーストアファイル内に 1 つ以上の「信頼できる証明書」がある必要があります。

</p><ul>

<li>証明応答が証明書チェーンの場合は、チェーンのトップの証明書 (その CA の公開鍵を認証する「ルート」CA の証明書) だけを必要とする<p>

</p></li><li>証明応答が単一の証明書の場合は、証明書に署名した CA の発行用の証明書が必要で、その証明書が自己署名されない場合は、さらにその証明書の署名者用の証明書を必要とする。 このようにして自己署名される「ルート」CA の証明書までそれぞれ証明書を必要とする

</li></ul>

<p>cacerts キーストアファイルは、5 つの VeriSign ルート CA 証明書を含んだ状態で出荷されているので、VeriSign の証明書を、信頼できる証明書としてキーストア内にインポートする必要はないかもしれません。ただし、ほかの CA に対して署名付き証明書を要求していて、この CA の公開鍵を認証する証明書が、cacerts にまだ追加されていない場合は、該当する CA からの証明書を、「信頼できる証明書」としてインポートする必要があります。

</p><p>通常、CA からの証明書は、自己署名証明書、またはほかの CA によって署名された証明書です (後者の場合は、該当するほかの CA の公開鍵を認証する証明書も必要)。たとえば、ABC という企業が CA だとします。 このとき、この CA の公開鍵を認証する自己署名証明書と考えられる ABCCA.cer という名前のファイルを、ABC から入手したとします。

</p><p>「信頼できる証明書」として証明書をインポートするときは、証明書が有効であることを慎重に確認する必要があります。まず、証明書の内容を表示し (<b>keytool</b> <code>-printcert</code> コマンドを使用するか、または <code>-noprompt</code> オプションを指定しないで <b>keytool</b> <code>-importcert</code> コマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィンガープリントと一致するかどうかを確認します。証明書を送信した人物に連絡し、この人物が提示した (または安全な公開鍵のリポジトリによって提示される) フィンガープリントと、上のコマンドで表示されたフィンガープリントとを比較します。フィンガープリントが一致すれば、送信途中でほかの何者か (攻撃者など) による証明書のすり替えが行われていないことを確認できます。送信途中でこの種の攻撃が行われていた場合、チェックを行わずに証明書をインポートすると、攻撃者によって署名されたすべてのものを信頼することになります。

</p><p>ABCCA.cer を有効な証明書として信頼する場合は、証明書をキーストアに追加できます。 たとえば、次のようにします。

</p><pre>    keytool -importcert -alias abc -file ABCCA.cer
</pre>

ABCCA.cer ファイルのデータを含む「信頼できる証明書」のエントリがキーストア内に作成され、該当するエントリに abc という別名が割り当てられます。

</blockquote>


<h3>CA からの証明応答のインポート</h3>

<blockquote>

<p>証明書署名要求の提出先の CA の公開鍵を認証する証明書をインポートしたあとは (または同種の証明書がすでに cacerts ファイル内に存在している場合は)、証明応答をインポートし、自己署名証明書を証明書チェーンで置き換えることができます。この証明書チェーンは、CA の応答がチェーンの場合、証明書署名要求に対する応答として CA から送り返された証明書チェーンです。 また、CA の応答が単一の証明書の場合は、この証明応答と、インポート先のキーストア内または cacerts キーストアファイル内にすでに存在する信頼できる証明書とを使って構築した証明書チェーンです。

</p><p>たとえば、証明書署名要求を VeriSign に送信したとします。送り返された証明書の名前が VSMarkJ.cer だとすると、次のようにして応答をインポートできます。

</p><pre>    keytool -importcert -trustcacerts -file VSMarkJ.cer
</pre>

</blockquote>


<h3>公開鍵を認証する証明書のエクスポート</h3>

<blockquote>

たとえば、<a href="jarsigner.html">jarsigner</a> を使って Java ARchive (JAR) ファイルに署名したとします。この JAR ファイルはクライアントによって使われますが、クライアント側では署名を認証したいと考えています。

<p>クライアントが署名を認証する方法の 1 つに、まず自分の公開鍵の証明書を「信頼できる」エントリとしてクライアントのキーストアにインポートする方法があります。そのためには、証明書をエクスポートして、クライアントに提供します。たとえば、次のようにして、証明書を <code>MJ.cer</code> という名前のファイルにコピーします。 このエントリには「mykey」という別名が使われているとします。

</p><pre>    keytool -exportcert -alias mykey -file MJ.cer
</pre>

証明書と署名付き JAR ファイルを入手したクライアントは、<b>jarsigner</b> ツールを使って署名を認証できます。

</blockquote>




<!--h3>Changing Your Distinguished Name but Keeping your Key Pair</h3>  <blockquote>  Suppose your distinguished name changes, for example because you have changed departments or moved to a different city. If desired, you may still use the public/private key pair you've previously used, and yet update your distinguished name. For example, suppose your name is Susan Miller, and you created your initial key entry with the alias <code>sMiller</code> and the distinguished name  <pre>  "cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"
</pre>  Suppose you change from the Finance Department to the Accounting Department. You can still use the previously-generated public/private key pair and yet update your distinguished name by doing the following.  First, copy (clone) your key entry:  <pre>    keytool -keyclone -alias sMiller -dest sMillerNew
</pre>  (This prompts for the store password and for the initial and destination private key passwords, since they aren't provided at the command line.) Now you need to change the certificate chain associated with the copy, so that the first certificate in the chain uses your different distinguished name. Start by generating a self-signed certificate with the appropriate name:  <pre>    keytool -selfcert -alias sMillerNew
      -dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
</pre>  <p>Then generate a Certificate Signing Request based on the information in this new certificate:  </p><pre>    keytool -certreq -alias sMillerNew
</pre>  When you get the CA certificate reply, import it:  <pre>    keytool -import -alias sMillerNew -file VSSMillerNew.cer
</pre>  After importing the certificate reply, you may want to remove the initial key entry that used your old distinguished name:  <pre>    keytool -delete -alias sMiller
</pre>  </blockquote> -->

<h3>キーストアのインポート</h3>
<blockquote>
<p>コマンド「importkeystore」を使えば、あるキーストアの全体を別のキーストア内にインポートできます。 これは、鍵や証明書といったソースキーストア内のすべてのエントリが、単一のコマンドを使ってターゲットキーストア内にインポートされることを意味します。このコマンドを使えば、異なるタイプのキーストア内に含まれるエントリをインポートすることができます。インポート時には、ターゲットキーストア内の新しいエントリはすべて、元と同じ別名および (秘密鍵や非公開鍵の場合は) 保護用パスワードを持ちます。ソースキーストア内の非公開鍵や秘密鍵の回復時に問題が発生した場合、<b>keytool</b> はユーザーにパスワードの入力を求めます。このコマンドは、別名の重複を検出すると、ユーザーに新しい別名の入力を求めます。 ユーザーは、新しい別名を指定することも、単純に既存の別名の上書きを <b>keytool</b> に許可することもできます。</p>

<p>たとえば、通常の JKS タイプのキーストア key.jks 内のエントリを PKCS #11 タイプのハードウェアベースのキーストア内にインポートするには、次のコマンドを使用できます。</p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
</pre>
<p>また、importkeystore コマンドを使えば、あるソースキーストア内の単一のエントリをターゲットキーストアにインポートすることもできます。この場合、上記の例で示したオプションに加え、インポート対象となる別名を指定する必要があります。srcalias オプションを指定する場合には、ターゲット別名もコマンド行から指定できるほか、秘密/非公開鍵の保護用パスワードやターゲット保護用パスワードも指定できます。そうすれば、プロンプトのまったく表示されない <b>keytool</b> コマンドを発行できます。これは、<b>keytool</b> コマンドをスクリプトファイルに含める際に非常に便利です。 次に例を示します。</p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
    -srcalias myprivatekey -destalias myoldprivatekey
    -srckeypass oldkeypass -destkeypass mynewkeypass
    -noprompt
</pre>

</blockquote>
</blockquote>


<h2>用語と警告</h2>

<blockquote>

<a name="KeyStore"></a>
<h3>キーストア</h3>

<blockquote>
キーストアは、暗号化の鍵と証明書を格納するための機能です。
</blockquote>

<ul>
<a name="KeyStoreEntries"></a>
<li><h4>キーストアのエントリ</h4>

<blockquote>

キーストアには異なるタイプのエントリを含めることができます。<b>keytool</b> でもっとも適用範囲の広いエントリタイプは、次の 2 つです。

<ol>

<li><b>鍵のエントリ</b> - 各エントリは、非常に重要な暗号化の鍵の情報を保持します。この情報は、許可していないアクセスを防ぐために、保護された形で格納されます。一般に、この種のエントリとして格納される鍵は、秘密鍵か、対応する公開鍵の<a href="#CertChains">証明書チェーン</a>を伴う非公開鍵です。<b>keytool</b> がこの両方のタイプのエントリを処理できるのに対し、<b>jarsigner</b> ツールは後者のタイプのエントリ、つまり非公開鍵とそれに関連付けられた証明書チェーンのみを処理します。<p>

</p></li><li><b>信頼できる証明書のエントリ</b> - 各エントリは、第三者からの公開鍵証明書を 1 つ含んでいます。この証明書は、「信頼できる証明書」と呼ばれます。 それは、証明書内の公開鍵が、証明書の「Subject」(所有者) によって特定されるアイデンティティーに由来するものであることを、キーストアの所有者が信頼するからです。証明書の発行者は、証明書に署名を付けることによって、その内容を保証します。

</li></ol>

</blockquote>



<a name="KeyStoreAliases"></a>
</li><li><h4>キーストアの別名</h4>

<blockquote>

<p>キーストアのすべてのエントリ (鍵および信頼できる証明書) は、一意の「別名」を介してアクセスされます。<i></i>

</p><p>別名を指定するのは、<a href="#genseckeyCmd">-genseckey</a> コマンドを使って秘密鍵を生成したり、<a href="#genkeypairCmd">-genkeypair</a> コマンドを使って鍵ペア (公開鍵と非公開鍵) を生成したり、<a href="#importCertCmd">-importcert</a> コマンドを使って証明書または証明書チェーンを信頼できる証明書のリストに追加したりするなど、特定のエンティティーをキーストアに追加する場合です。これ以後、<b>keytool</b> コマンドでエンティティーを参照する場合は、このときに指定した別名を使用する必要があります。

</p><p>たとえば、<tt>duke</tt> という別名を使って新しい公開鍵と非公開鍵のペアを生成し、公開鍵を自己署名証明書 (<a href="#CertChains">「証明書チェーン」</a>を参照) でラップするとします。 この場合は、次のコマンドを実行します。

</p><pre>    keytool -genkeypair -alias duke -keypass dukekeypasswd
</pre>

ここでは、初期パスワードとして dukekeypasswd を指定しています。 以後、別名 <code>duke</code> に関連付けられた非公開鍵にアクセスするコマンドを実行するときは、このパスワードが必要になります。duke の非公開鍵のパスワードをあとから変更するには、次のコマンドを実行します。

<pre>    keytool -keypasswd -alias duke -keypass dukekeypasswd -new newpass
</pre>

パスワードが、dukekeypasswd から newpass に変更されます。

<p>注 -テストを目的とする場合、または安全であることがわかっているシステムで実行する場合以外は、コマンド行やスクリプトでパスワードを指定しないでください。必要なパスワードのオプションをコマンド行で指定しなかった場合は、パスワードの入力を求められます。

</p></blockquote>


<a name="KeyStoreImplementation"></a>
</li><li><h4>キーストアの実装</h4>

<blockquote>

<code>java.security</code> パッケージで提供される <code>KeyStore</code> クラスには、キーストア内の情報に対するアクセスと変更を行うための明確に定義されたインタフェースが用意されています。キーストアの固定実装としては、それぞれが特定の「タイプ」のキーストアを対象とする複数の異なる実装が存在可能です。<i></i>

<p>現在、<b>keytool</b> と <b>jarsigner</b> の 2 つのコマンド行ツールと、<b>Policy Tool</b> という名前の 1 つの GUI ベースのツールが、キーストアの実装を使用しています。<code>KeyStore</code> は public として使用可能なので、JDK ユーザーは <code>KeyStore</code> を使ったほかのセキュリティーアプリケーションも作成できます。

</p><p>キーストアには、Sun が提供する組み込みのデフォルトの実装があります。これは、JKS という名前の独自のキーストアタイプ (形式) を利用するもので、キーストアをファイルとして実装しています。この実装では、個々の非公開鍵は個別のパスワードによって保護され、キーストア全体の整合性も (非公開鍵とは別の) パスワードによって保護されます。

</p><p>キーストアの実装は、プロバイダベースです。具体的には、<code>KeyStore</code> が提供するアプリケーションインタフェースは、Service Provider Interface (SPI) という形で実装されています。つまり、対応する <code>KeystoreSpi</code> 抽象クラス (これも <code>java.security</code> パッケージに含まれている) があり、このクラスが Service Provider Interface のメソッドを定義しています。 これらのメソッドは、「プロバイダ」が実装しなければなりません。ここで、「プロバイダ」とは、Java Security API によってアクセス可能なサービスのサブセットに対し、その固定実装を提供するパッケージまたはパッケージの集合のことです。したがって、キーストアの実装を提供するには、<a href="../../guides/security/crypto/HowToImplAProvider.html">「Java(TM) 暗号化アーキテクチャー用プロバイダの実装方法」</a>で説明しているように、クライアントが「プロバイダ」を実装し、KeystoreSpi サブクラスの実装を提供する必要があります。

</p><p>アプリケーションでは、<code>KeyStore</code> クラスが提供する getInstance ファクトリメソッドを使うことで、さまざまなプロバイダから異なる「タイプ」のキーストアの実装を選択できます。<i></i>キーストアのタイプは、キーストア情報の格納形式とデータ形式を定義するとともに、キーストア内の非公開/秘密鍵とキーストア自体の整合性を保護するために使われるアルゴリズムを定義します。異なるタイプのキーストアの実装には、互換性はありません。

</p><p><b>keytool</b> は、任意のファイルベースのキーストア実装で動作します。keytool は、コマンド行から渡されたキーストアの場所をファイル名として扱い、これを FileInputStream に変換して、FileInputStream からキーストアの情報をロードします。一方、<b>jarsigner</b> ツールと <b>policytool</b> ツールは、URL で指定可能な任意の場所からキーストアを読み込むことができます。

</p><p><b>keytool</b> と <b>jarsigner</b> の場合、<i>-storetype</i> オプションを使ってコマンド行でキーストアのタイプを指定できます。<b>Policy Tool</b>の場合は、「キーストア」メニューによってキーストアのタイプを指定できます。

</p><p>キーストアのタイプを明示的に指定しない場合、keytool、jarsigner、および policytool の各ツールは、セキュリティープロパティーファイル内で指定された <code>keystore.type</code> プロパティーの値に基づいてキーストアの実装を選択します。セキュリティープロパティーファイルは、<tt>java.security</tt> という名前でセキュリティープロパティーディレクトリ <code><i>java.home</i>/lib/security</code> に置かれています。<i> java.home</i> は、実行環境のディレクトリ (SDK の <tt>jre</tt> ディレクトリまたは Java 2 Runtime Environment の最上位ディレクトリ) です。

</p><p>各ツールは、<code>keystore.type</code> の値を取得し、この値で指定されたタイプのキーストアを実装しているプロバイダが見つかるまで、現在インストールされているすべてのプロバイダを調べます。目的のプロバイダが見つかると、そのプロバイダからのキーストアの実装を使います。

</p><p><code>KeyStore</code> クラスでは <code>getDefaultType</code> という名前の static メソッドが定義されており、アプリケーションとアプレットはこのメソッドを使うことで <code>keystore.type</code> プロパティーの値を取得できます。次のコードは、デフォルトのキーストアタイプ (<code>keystore.type</code> プロパティーで指定されたタイプ) のインスタンスを生成します。

</p><pre>    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</pre>

<p>デフォルトのキーストアタイプは JKS (Sun が提供する独自のタイプのキーストアの実装) です。これは、セキュリティープロパティーファイル内の次の行によって指定されています。

</p><pre>    keystore.type=jks
</pre>

<p>各ツールでデフォルト以外のキーストアの実装を使用するには、上の行を変更して別のキーストアのタイプを指定します。

</p><p>たとえば、pkcs12 と呼ばれるタイプのキーストアの実装を提供しているプロバイダパッケージを使用するには、上の行を次のように変更します。

</p><pre>    keystore.type=pkcs12
</pre>

注:キーストアのタイプの指定では、大文字と小文字は区別されません。たとえば、JKS と jks は同じものとして扱われます。

</blockquote>

</li></ul>

<h3><a name="Certificates">証明書</a></h3>

<blockquote>
<b>証明書</b> (<b>公開鍵証明書</b>とも呼ぶ) とは、あるエンティティー (「発行者」) からのデジタル署名付きの文書のことです。 証明書には、ほかのあるエンティティー (「署名者」) の公開鍵 (およびその他の情報) が特別な値を持っていることが書かれています。<i></i><i></i>
</blockquote>

<ul>
<a name="CertificateTerms"></a>
<li><h4>証明書の用語</h4>
<blockquote>

<p></p><dl><dt><i>公開鍵</i>
</dt><dd>
公開鍵は、特定のエンティティーに関連付けられた数です。 公開鍵は、該当するエンティティーとの間に信頼できる関係を持つ必要があるすべての人に対して公開することを意図したものです。公開鍵は、署名を検証するのに使われます。
</dd><dt><i>デジタル署名</i>
</dt><dd>
データが「<i>デジタル署名</i>」されると、そのデータは、エンティティーの「アイデンティティー」と、そのエンティティーがデータの内容について知っていることを証明する署名とともに格納されます。エンティティーの非公開鍵を使ってデータに署名を付けると、データの偽造は不可能になります。
</dd><dt><i>アイデンティティー</i>
</dt><dd>
エンティティーを特定するための既知の方法です。システムによっては、公開鍵をアイデンティティーにするものがあります。 公開鍵のほかにも、Unix UID や電子メールアドレス、X.509 識別名など、さまざまなものをアイデンティティーとすることができます。
</dd><dt><i>署名</i>
</dt><dd>
署名は、なんらかのデータを基にエンティティー (署名者。 証明書に関しては発行者とも呼ばれる) の非公開鍵を使って計算されます。<i></i><i></i>
</dd><dt><i>非公開鍵</i>
</dt><dd>
非公開鍵は特定のエンティティーだけが知っている数のことで、この数のことを、そのエンティティーの非公開鍵といいます。非公開鍵は、ほかに知られないように秘密にしておくことが前提になっています。 非公開鍵と公開鍵は、すべての公開鍵暗号化システムで対になって存在しています。DSA などの典型的な公開鍵暗号化システムの場合、1 つの非公開鍵は正確に 1 つの公開鍵に対応します。非公開鍵は、署名を計算するのに使われます。
</dd><dt><i>エンティティー</i>
</dt><dd>
エンテンティーは、人、組織、プログラム、コンピュータ、企業、銀行など、一定の度合いで信頼の対象となるさまざまなものを指します。
</dd></dl>

<p>
公開鍵暗号化では、その性質上、ユーザーの公開鍵にアクセスする必要があります。大規模なネットワーク環境では、互いに通信しているエンティティー間で以前の関係が引き続き確立されていると仮定したり、使われているすべての公開鍵を収めた信頼できるリポジトリが存在すると仮定したりすることは不可能です。このような公開鍵の配布に関する問題を解決するために証明書が考案されました。現在では、「証明書発行局 (CA)」が信頼できる第三者として機能します。<i></i>CA は、ほかのエンティティーの証明書に署名する (発行する) 行為を、信頼して任されているエンティティー (企業など) です。CA は法律上の契約に拘束されるので、有効かつ信頼できる証明書だけを作成するものとして扱われます。<a href="http://www.verisign.com/">VeriSign</a>、<a href="http://www.thawte.com/">Thawte</a>、<a href="http://www.entrust.com/">Entrust</a> をはじめ、多くの CA が存在します。Netscape や Microsoft の認証サーバー、Entrust の CA 製品などを所属組織内で利用すれば、独自の証明書発行局を運営することも可能です。

</p><p><b>keytool</b> を使うと、証明書の表示、インポート、およびエクスポートを行うことができます。また、自己署名証明書を生成することもできます。

</p><p>現在、<b>keytool</b> は X.509 証明書を対象にしています。
</p></blockquote>

<a name="X509Cert"></a>
</li><li><h4>X.509 証明書</h4>

<blockquote>

X.509 規格では、証明書に含める情報が定義されており、この情報を証明書に書き込む方法 (データ形式) についても記述されています。証明書のすべてのデータは、ASN.1/DER と呼ばれる 2 つの関連規格を使って符号化されます。<i>Abstract Syntax Notation 1</i> はデータについて記述しています。<i>Definite Encoding Rules</i> は、データの保存および転送の方法について記述しています。

<p>すべての X.509 証明書は、署名のほかに次のデータを含んでいます。

</p><dl><dt><i>バージョン</i>
</dt><dd>証明書に適用される X.509 規格のバージョンを特定します。 証明書に指定できる情報は、バージョンによって異なります。これまでに、3 つのバージョンが定義されています。<b>keytool</b> では、v1、v2、および v3 の証明書のインポートとエクスポートが可能です。keytool が生成するのは、v3 の証明書です。

<p>
「X.509 Version 1」は、1988 年から利用されて広く普及しており、もっとも一般的です。<i></i>

</p><p>「X.509 Version 2」では、Subject や発行者の名前をあとで再利用できるようにするために、Subject と発行者の一意識別子の概念が導入されました。<i></i>ほとんどの証明書プロファイル文書では、名前を再使用しないことと、証明書で一意な識別子を使わないことが、強く推奨されています。Version 2 の証明書は、広くは使われていません。

</p><p>「X.509 Version 3」はもっとも新しい (1996 年) 規格で、エクステンションの概念をサポートしています。<i></i>エクステンションは誰でも定義することができ、証明書に含めることができます。現在使われている一般的なエクステンションとしては、KeyUsage (「署名専用」など、鍵の使用を特定の目的に制限する)、AlternativeNames (DNS 名、電子メールアドレス、IP アドレスなど、ほかのアイデンティティーを公開鍵に関連付けることができる) などがあります。<i></i><i></i>エクステンションには、critical というマークを付けて、そのエクステンションのチェックと使用を義務づけることができます。<i></i>たとえば、critical とマークされ、KeyCertSign が設定された KeyUsage エクステンションが証明書に含まれている場合、この証明書を SSL 通信中に提示すると、証明書が拒否されます。 これは、証明書のエクステンションによって、関連する非公開鍵が証明書の署名専用として指定されており、SSL では使用できないためです。
</p>

</dd><dt><i>シリアル番号</i>
</dt><dd>証明書を作成したエンティティーは、そのエンティティーが発行するほかの証明書と区別するために、証明書にシリアル番号を割り当てます。この情報は、さまざまな方法で使われます。 たとえば、証明書が取り消されると、シリアル番号が証明書の取り消しリスト (CRL) に格納されます。

<p></p></dd><dt><i>署名アルゴリズム識別子</i>
</dt><dd>証明書に署名を付けるときに CA が使ったアルゴリズムを特定します。

<p></p></dd><dt><i>発行者名</i>
</dt><dd>証明書に署名を付けたエンティティーの <a href="#DName">X.500 識別名</a>です。エンティティーは、通常は CA です。この証明書を使うことは、証明書に署名を付けたエンティティーを信頼することを意味します。「ルート」つまり「トップレベル」の CA の証明書など、場合によっては発行者が自身の証明書に署名を付けることがある点に注意してください。<i></i>

<p></p></dd><dt><i>有効期間</i>
</dt><dd>各証明書は、限られた期間だけ有効になります。この期間は開始の日時と終了の日時によって指定され、数秒の短い期間から 100 年という長期にわたることもあります。選択される有効期間は、証明書への署名に使われる非公開鍵の強度や証明書に支払う金額など、さまざまな要因で異なります。有効期間は、使用する非公開鍵が損なわれない場合に、エンティティーが公開鍵を信頼できると期待される期間です。

<p></p></dd><dt><i>Subject 名</i>
</dt><dd>証明書で公開鍵が識別されているエンティティーの名前です。この名前は X.500 標準を使うので、インターネット全体で一意なものと想定されます。これは、エンティティーの <a href="#DName">X.500 識別名</a> (DN) です。 次に例を示します。
<pre>    CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</pre>
これらはそれぞれ主体の通称、組織単位、組織、国を表します。

<p></p></dd><dt><i>Subject の公開鍵情報</i>
</dt><dd>名前を付けられたエンティティーの公開鍵とアルゴリズム識別子です。 アルゴリズム識別子では、公開鍵に対して使われている公開鍵暗号化システムおよび関連する鍵パラメータが指定されています。
</dd></dl>

</blockquote>


<a name="CertChains"></a>
</li><li><h4>証明書チェーン</h4>

<blockquote>

<p><b>keytool</b> では、非公開鍵および関連する証明書「チェーン」を含むキーストアの「鍵」エントリを作成し、管理することができます。このようなエントリでは、非公開鍵に対応する公開鍵は、チェーンの最初の証明書に含まれています。

</p><p>鍵を初めて作成すると (<a href="#genkeypairCmd">-genkeypair</a> コマンドを参照)、「自己署名証明書」という 1 つの要素だけを含むチェーンが開始されます。<i></i>自己署名証明書は、発行者 (署名者) が主体 (証明書で認証されている公開鍵の持ち主) と同じである証明書のことです。<code>-genkeypair</code> コマンドを呼び出して新しい公開鍵と非公開鍵のペアを作成すると、公開鍵は常に自己署名証明書でラップされます。

</p><p>このあと、証明書署名要求 (CSR) が生成されて (<a href="#certreqCmd">-certreq</a> コマンドを参照)、CSR が証明書発行局 (CA) に送信されると、CA からの応答がインポートされ (<a href="#importCertCmd">-importcert</a> コマンドを参照)、元の自己署名証明書は証明書チェーンによって置き換えられます。チェーンの最後にあるのは、Subject の公開鍵を認証した CA が発行した証明書 (応答) です。チェーン内のその前の証明書は、「CA」の公開鍵を認証する証明書です。<i></i>

</p><p>CA の公開鍵を認証する証明書は、多くの場合、自己署名証明書 (つまり CA が自身の公開鍵を認証した証明書) であり、これはチェーンの最初の証明書になります。場合によっては、CA が証明書のチェーンを返すこともあります。この場合、チェーン内の最後の証明書 (CA によって署名され、鍵エントリの公開鍵を認証する証明書) に変わりはありませんが、チェーン内のその前の証明書は、CSR の送信先の CA とは「別の」CA によって署名され、CSR の送信先の CA の公開鍵を認証する証明書になります。<i></i>さらに、チェーン内のその前の証明書は、次の CA の鍵を認証する証明書になります。 以下同様に、自己署名された「ルート」証明書に達するまでチェーンが続きます。したがって、チェーン内の (最初の証明書以後の) 各証明書では、チェーン内の次の証明書の署名者の公開鍵が認証されていることになります。

</p><p>多くの CA は、チェーンをサポートせずに発行済みの証明書だけを返します。 特に、中間の CA が存在しないフラットな階層構造の場合は、その傾向が顕著です。このような場合は、キーストアにすでに格納されている信頼できる証明書情報から、証明書チェーンを確立する必要があります。

</p><p>別の応答形式 (PKCS#7 で定義されている形式) でも、発行済み証明書に加え、証明書チェーンのサポートが含まれています。<b>keytool</b> では、どちらの応答形式も扱うことができます。

</p><p>トップレベル (ルート) CA の証明書は、自己署名証明書です。ただし、ルートの公開鍵に対する信頼は、ルートの証明書自体から導き出されるものではなく (たとえば、VeriSign ルート CA のような有名な識別名を使った自己署名証明書を作成すること自体は誰でも可能)、新聞などのほかの情報源に由来するものです。ルート CA の公開鍵は広く知られています。ルート CA の公開鍵を証明書に格納する理由は、証明書という形式にすることで多くのツールから利用できるようになるからにすぎません。 つまり、証明書は、ルート CA の公開鍵を運ぶ「媒体」として利用されるだけです。ルート CA の証明書をキーストアに追加するときは、その前に証明書の内容を表示し (<code>-printcert</code> オプションを使用)、表示されたフィンガープリントと、新聞やルート CA の Web ページなどから入手した既知のフィンガープリントとを比較する必要があります。

</p></blockquote>

<a name="cacerts"></a>
</li><li><h4>cacerts 証明書ファイル</h4>

<blockquote>

<p><b>cacerts </b>証明書ファイルは、セキュリティープロパティーディレクトリ <code><i>java.home</i>/lib/security</code> に置かれています。<i> java.home</i> は、実行環境のディレクトリ (SDK の <tt>jre</tt> ディレクトリまたは Java 2 Runtime Environment の最上位ディレクトリ) です。

</p><p>cacerts ファイルは、CA の証明書を含む、システム全体のキーストアです。システム管理者は、キーストアタイプに jks を指定することで、<b>keytool</b> を使ってこのファイルの構成と管理を行うことができます。cacerts キーストアファイルは、次の別名および X.500 所有者識別名を持ついくつかのルート CA 証明書を含んだ状態で出荷されています。 </p><p>

</p>            <ul>
<li><b>Alias</b>:thawtepersonalfreemailca<br /> <b>Owner DN</b>:EmailAddress=personal-freemail@thawte.com, <br /> CN=Thawte Personal Freemail CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepersonalbasicca<br /> <b>Owner DN</b>:EmailAddress=personal-basic@thawte.com, <br /> CN=Thawte Personal Basic CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepersonalpremiumca<br /> <b>Owner DN</b>:EmailAddress=personal-premium@thawte.com, <br /> CN=Thawte Personal Premium CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawteserverca<br /> <b>Owner DN</b>:EmailAddress=server-certs@thawte.com, <br /> CN=Thawte Server CA, OU=Certification Services Division, <br /> O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepremiumserverca<br /> <b>Owner DN</b>:EmailAddress=premium-server@thawte.com, <br /> CN=Thawte Premium Server CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:verisignclass1ca<br /> <b>Owner DN</b>:OU=Class 1 Public Primary Certification Authority, <br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass2ca<br /> <b>Owner DN</b>:OU=Class 2 Public Primary Certification Authority, <br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass3ca<br /> <b>Owner DN</b>:OU=Class 3 Public Primary Certification Authority, <br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignserverca<br /> <b>Owner DN</b>:OU=Secure Server Certification Authority, <br /> O=&quot;RSA Data Security, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass1g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU=&quot;(c) 1998 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=Class 1 Public Primary Certification Authority - G2,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass1g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 1 Public Primary Certification Authority - G3, OU=&quot;(c) 1999 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=VeriSign Trust Network,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass2g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU=&quot;(c) 1998 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=Class 2 Public Primary Certification Authority - G2,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass2g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 2 Public Primary Certification Authority - G3,<br /> OU=&quot;(c) 1999 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=VeriSign Trust Network,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass3g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU=&quot;(c) 1998 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=Class 3 Public Primary Certification Authority - G2,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:verisignclass3g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 3 Public Primary Certification Authority - G3,<br /> OU=&quot;(c) 1999 VeriSign, Inc. - For authorized use only&quot;,<br /> OU=VeriSign Trust Network,<br /> O=&quot;VeriSign, Inc.&quot;, C=US</li>

<li><b>Alias</b>:baltimorecodesigningca<br /> <b>Owner DN</b>:CN=Baltimore CyberTrust Code Signing Root,<br /> OU=CyberTrust, O=Baltimore, C=IE</li>

<li><b>Alias</b>:gtecybertrustglobalca<br /> <b>Owner DN</b>:CN=GTE CyberTrust Global Root,<br /> OU=&quot;GTE CyberTrust Solutions, Inc.&quot;, O=GTE Corporation, C=US</li>

<li><b>Alias</b>:baltimorecybertrustca<br /> <b>Owner DN</b>:CN=Baltimore CyberTrust Root,<br /> OU=CyberTrust, O=Baltimore, C=IE</li>

<li><b>Alias</b>:gtecybertrust5ca<br /> <b>Owner DN</b>:CN=GTE CyberTrust Root 5,<br /> OU=&quot;GTE CyberTrust Solutions, Inc.&quot;, O=GTE Corporation, C=US</li>

<li><b>Alias</b>:entrustclientca<br /> <b>Owner DN</b>:CN=Entrust.net Client Certification Authority,<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/Client_CA_Info/CPS incorp. by ref. limits liab.,<br /> O=Entrust.net, C=US</li>

<li><b>Alias</b>:entrustglobalclientca<br /> <b>Owner DN</b>:CN=Entrust.net Client Certification Authority,<br /> OU=(c) 2000 Entrust.net Limited,<br /> OU=www.entrust.net/GCCA_CPS incorp. by ref. (limits liab.),<br /> O=Entrust.net</li>

<li><b>Alias</b>:entrust2048ca<br /> <b>Owner DN</b>:CN=Entrust.net Certification Authority (2048),<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.),<br /> O=Entrust.net</li>

<li><b>Alias</b>:entrustsslca<br /> <b>Owner DN</b>:CN=Entrust.net Secure Server Certification Authority,<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/CPS incorp. by ref. (limits liab.),<br /> O=Entrust.net, C=US</li>

<li><b>Alias</b>:entrustgsslca<br /> <b>Owner DN</b>:CN=Entrust.net Secure Server Certification Authority,<br /> OU=(c) 2000 Entrust.net Limited,<br /> OU=www.entrust.net/SSL_CPS incorp. by ref. (limits liab.),<br /> O=Entrust.net</li>

<li><b>Alias</b>:godaddyclass2ca<br /> <b>Owner DN</b>:OU=Go Daddy Class 2 Certification Authority,<br /> O=&quot;The Go Daddy Group, Inc.&quot;, C=US</li>

<li><b>Alias</b>:starfieldclass2ca<br /> <b>Owner DN</b>:OU=Starfield Class 2 Certification Authority,<br /> O=&quot;Starfield Technologies, Inc.&quot;, C=US</li>

<li><b>Alias</b>:valicertclass2ca<br /> <b>Owner DN</b>:EMAILADDRESS=info@valicert.com,<br /> CN=http://www.valicert.com/,<br /> OU=ValiCert Class 2 Policy Validation Authority,<br /> O=&quot;ValiCert, Inc.&quot;, L=ValiCert Validation Network</li>

<li><b>Alias</b>:geotrustglobalca<br /> <b>Owner DN</b>:CN=GeoTrust Global CA,<br /> O=GeoTrust Inc., C=US</li>

<li><b>Alias</b>:equifaxsecureca<br /> <b>Owner DN</b>:OU=Equifax Secure Certificate Authority,<br /> O=Equifax, C=US</li>

<li><b>Alias</b>:equifaxsecureebusinessca1<br /> <b>Owner DN</b>:CN=Equifax Secure eBusiness CA-1,<br /> O=Equifax Secure Inc., C=US</li>

<li><b>Alias</b>:equifaxsecureebusinessca2<br /> <b>Owner DN</b>:OU=Equifax Secure eBusiness CA-2,<br /> O=Equifax Secure, C=US</li>

<li><b>Alias</b>:equifaxsecureglobalebusinessca1<br /> <b>Owner DN</b>:CN=Equifax Secure Global eBusiness CA-1,<br /> O=Equifax Secure Inc., C=US</li>

<li><b>Alias</b>:soneraclass1ca<br /> <b>Owner DN</b>:CN=Sonera Class1 CA, O=Sonera, C=FI</li>

<li><b>Alias</b>:soneraclass2ca<br /> <b>Owner DN</b>:CN=Sonera Class2 CA, O=Sonera, C=FI</li>

<li><b>Alias</b>:comodoaaaca<br /> <b>Owner DN</b>:CN=AAA Certificate Services,<br/> O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB</li>

<li><b>Alias</b>:addtrustclass1ca<br /> <b>Owner DN</b>:CN=AddTrust Class 1 CA Root,<br/> OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:addtrustexternalca<br /> <b>Owner DN</b>:CN=AddTrust External CA Root,<br/> OU=AddTrust External TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:addtrustqualifiedca<br /> <b>Owner DN</b>:CN=AddTrust Qualified CA Root,<br/> OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:utnuserfirsthardwareca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Hardware,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utnuserfirstclientauthemailca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Client Authentication and Email,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utndatacorpsgcca<br /> <b>Owner DN</b>:CN=UTN - DATACorp SGC,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utnuserfirstobjectca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Object,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>
            </ul>


<p>cacerts キーストアファイルの初期パスワードは、changeit です。システム管理者は、SDK のインストール後、このファイルのパスワードとデフォルトアクセス権を変更する必要があります。


</p><blockquote>
<hr />
<b>重要:<code>cacerts</code> ファイルを確認してください。</b> <br /><code>cacerts</code> ファイル内の CA は、署名および他のエンティティーへの証明書発行のためのエンティティーとして信頼されるため、<code>cacerts</code> ファイルの管理は慎重に行う必要があります。<code>cacerts</code> ファイルには、信頼する CA の証明書だけが含まれていなければなりません。ユーザーは、自身の責任において、<code>cacerts</code> ファイルにバンドルされている信頼できるルート CA 証明書を検証し、信頼性に関する独自の決定を行います。信頼できない CA 証明書を <code>cacerts</code> ファイルから削除するには、<code>keytool</code> コマンドの削除オプションを使用します。<code>cacerts</code> ファイルは JRE のインストールディレクトリにあります。このファイルを編集するアクセス権がない場合は、システム管理者に連絡してください。 <br />
<hr />
</blockquote>
</blockquote>


<a name="EncodeCertificate"></a>
</li><li><h4>インターネット RFC 1421 証明書符号化規格</h4>

<blockquote>

<p>多くの場合、証明書は、バイナリ符号化ではなく、インターネット RFC 1421 規格で定義されている出力可能符号化方式を使って格納されます。「Base 64 符号化」とも呼ばれるこの証明書形式では、電子メールやその他の機構を通じて、ほかのアプリケーションに証明書を容易にエクスポートできます。

</p><p><code>-importcert</code> コマンドと <code>-printcert</code> コマンドでは、この形式の証明書とバイナリ符号化の証明書を読み込むことができます。

</p><p><code>-exportcert</code> コマンドでは、デフォルトでバイナリ符号化の証明書が出力されます。 ただし、<code>-rfc</code> オプションを指定した場合は、出力可能符号化方式の証明書が出力されます。

</p><p><code>-list</code> コマンドでは、デフォルトで証明書の MD5 フィンガープリントが出力されます。<code>-v</code> オプションを指定すると、人間が読むことのできる形式で証明書が出力されます。 一方、<code>-rfc</code> オプションを指定すると、出力可能符号化方式で証明書が出力されます。

</p><p>出力可能符号化方式で符号化された証明書は、次の行で始まります。

</p><pre>-----BEGIN CERTIFICATE-----
</pre>

<p>最後は、次の行で終わります。

</p><pre>-----END CERTIFICATE-----
</pre>

</blockquote>

</li></ul>

<a name="DName"></a>
<h3>X.500 識別名</h3>

<blockquote>

X.500 識別名は、エンティティーを特定するために使われます。 たとえば、X.509 証明書の <code>subject</code> フィールドと <code>issuer</code> (署名者) フィールドで指定される名前は、X.500 識別名です。<b> keytool</b> は、次のサブパートをサポートしています。

<ul>

<li><i>commonName</i> - 人の通称。 「Susan Jones」など<p>

</p></li><li><i>organizationUnit</i> - 小さな組織 (部、課など) の名称。 「仕入部」など<p>

</p></li><li><i>organizationName</i> - 大きな組織の名称。 「ABCSystems, Inc.」など<p>

</p></li><li><i>localityName</i> - 地域 (都市) 名。 「Palo Alto」など<p>

</p></li><li><i>stateName</i> - 州名または地方名。 「California」など<p>

</p></li><li><i>country</i> - 2 文字の国番号。 「CH」など<p>

</p></li></ul>

<p><code>-genkeypair</code> <!--or <code>-selfcert</code--> コマンド<!--s-->の <code>-dname</code> オプションの値として識別名文字列を指定する場合は、次の形式で指定する必要があります。

</p><pre>CN=<i>cName</i>, OU=<i>orgUnit</i>, O=<i>org</i>, L=<i>city</i>, S=<i>state</i>, C=<i>countryCode</i>
</pre>

<p>イタリック体の項目は、実際に指定する値を表します。 短縮形のキーワードの意味は、次のとおりです。

</p><pre>	CN=commonName
	OU=organizationUnit
	O=organizationName
	L=localityName
	S=stateName
	C=country
</pre>

<p>次に示すのは、識別名文字列の例です。

</p><pre>CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino, S=California, C=US
</pre>

次は、この文字列を使ったコマンドの例です。

<pre>keytool -genkeypair -dname "CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino,
S=California, C=US" -alias mark
</pre>

<p>キーワードの短縮形では、大文字と小文字は区別されません。たとえば、CN、cn、および Cn は、どれも同じものとして扱われます。

</p><p>一方、キーワードの指定順序には意味があり、各サブコンポーネントは上に示した順序で指定する必要があります。ただし、サブコンポーネントをすべて指定する必要はありません。たとえば、次のように一部のサブコンポーネントだけを指定できます。

</p><pre>CN=Steve Meier, OU=SunSoft, O=Sun, C=US
</pre>

<p>識別名文字列の値にコンマが含まれる場合に、コマンド行で文字列を指定するときには、次のようにコンマを文字 \ でエスケープする必要があります。

</p><pre>   cn=peter schuster, o=Sun Microsystems\, Inc., o=sun, c=us
</pre>

<p>識別名文字列をコマンド行で指定する必要はありません。識別名を必要とするコマンドを実行するときに、コマンド行で識別名を指定しなかった場合は、各サブコンポーネントの入力を求められます。この場合は、コンマを文字 \ でエスケープする必要はありません。
</p></blockquote>


<a name="TrustedCertWarning"></a>
<h3>信頼できる証明書のインポートに関する注意事項</h3>

<blockquote>

重要:信頼できる証明書として証明書をインポートする前に、証明書の内容を慎重に調べてください。

<p>まず、証明書の内容を表示し (<code>-printcert</code> コマンドを使用するか、または <code>-noprompt</code> オプションを指定しないで <code>-import</code> コマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィンガープリントと一致するかどうかを確認します。たとえば、あるユーザーから証明書が送られてきて、この証明書を <code>/tmp/cert</code> という名前でファイルに格納しているとします。この場合は、信頼できる証明書のリストにこの証明書を追加する前に、<code>-printcert</code> コマンドを実行してフィンガープリントを表示できます。 たとえば、次のようにします。

</p><pre>  keytool -printcert -file /tmp/cert
    Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Serial Number: 59092b34
    Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
    Certificate Fingerprints:
         MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
         SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
</pre>

次に、証明書を送信した人物に連絡し、この人物が提示したフィンガープリントと、上のコマンドで表示されたフィンガープリントとを比較します。フィンガープリントが一致すれば、送信途中でほかの何者か (攻撃者など) による証明書のすり替えが行われていないことを確認できます。送信途中でこの種の攻撃が行われていた場合、チェックを行わずに証明書をインポートすると、攻撃者によって署名されたすべてのもの (攻撃的意図を持つクラスファイルを含んだ JAR ファイルなど) を信頼することになります。

<p>注:証明書をインポートする前に必ず <code>-printcert</code> コマンドを実行しなければならないわけではありません。 キーストア内の信頼できる証明書のリストに証明書を追加する前に <code>-importcert</code> コマンドを実行すると、証明書の情報が表示され、確認を求めるメッセージが表示されます。インポート操作は、この時点で中止できます。ただし、確認メッセージが表示されるのは、<code>-importcert</code> コマンドを <code>-noprompt</code> オプションを指定せずに実行した場合だけです。<code>-noprompt</code> オプションが指定されている場合、ユーザーとの対話は行われません。

</p></blockquote>


<a name="PasswordWarning"></a>
<h3>パスワードに関する注意事項</h3>

<blockquote>

<p>キーストアに対する操作を行うほとんどのコマンドでは、ストアのパスワードが必要です。また、一部のコマンドでは、非公開/秘密鍵のパスワードが必要になることがあります。

</p><p>パスワードはコマンド行で指定できます (ストアのパスワードには <code>-storepass</code> オプション、非公開鍵のパスワードには <code>-keypass</code> オプションを使用)。ただし、テストを目的とする場合、または安全であることがわかっているシステムで実行する場合以外は、コマンド行やスクリプトでパスワードを指定しないでください。

</p><p>必要なパスワードのオプションをコマンド行で指定しなかった場合は、パスワードの入力を求められます。
</p></blockquote>


</blockquote>

<h2><a name="SeeAlso">関連項目</a></h2>

<blockquote>

<ul>

<li>
<p><a href="jar.html">jar</a> ツールのドキュメント</p>
</li>
<li>
<p><a href="jarsigner.html">jarsigner</a> ツールのドキュメント</p>
</li>
<li>
<p><b>keytool</b> の使用例については、<a href="http://java.sun.com/docs/books/tutorial"><b>「Java Tutorial」</b></a>の<a href="http://java.sun.com/docs/books/tutorial/security/index.html"><b>「Security」</b></a>を参照
    
  </p>
</li>
</ul>

</blockquote>


<h2><a name="Changes">変更点</a></h2>
<blockquote>
<p>Java SE 6 で keytool のコマンドインタフェースが変更されました。</p>
<p><b>keytool</b> は、ユーザーがパスワードを入力する際にその入力内容を表示しなくなりました。ユーザーはパスワード入力時にその入力内容を確認できなくなったため、初期キーストアパスワードを設定したり鍵パスワードを変更したりするなど、パスワードの設定や変更を行うたびにパスワードの再入力を求められます。</p>
<p>変更されたコマンドの中には、名前が変更されただけのものもあれば、廃止されてこのドキュメントに記載されなくなったものもあります。以前のすべてのコマンド (名前が変更されたものと廃止されたものの両方) は、このリリースでも引き続きサポートされており、今後のリリースでもサポートされる予定です。keytool のコマンドインタフェースに加えられたすべての変更点の概要を、次に示します。
</p>
<p>名前が変更されたコマンド:
</p><ul>
<li><code>-export</code> の名前が <a href="#exportCertCmd"><code>-exportcert</code></a> に変更</li>
<li><code>-genkey</code> の名前が <a href="#genkeypairCmd"><code>-genkeypair</code></a> に変更</li>
<li><code>-import</code> の名前が <a href="#importCertCmd"><code>-importcert</code></a> に変更</li>
</ul>
<p>廃止されてドキュメントに記載されなくなったコマンド:
</p><ul>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#keycloneCmd"><code>-keyclone</code></a></li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#identitydbCmd"><code>-identitydb</code></a></li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#selfcertCmd"><code>-selfcert</code></a></li>
</ul>
</blockquote>





<HR>
<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN="TOP"><TD><P><FONT SIZE="-2">
<A HREF=../../../../legal/cpyr.html>Copyright &#169;</A> 1993, 2011, Oracle and/or its affiliates. All rights reserved.</FONT></P><FONT SIZE="-1"> Please send comments using this <a href=http://download.oracle.com/javase/feedback.html>Feedback</a> page.</FONT> </TD>
<TD ALIGN=RIGHT> <IMG SRC="../../../../images/oraclelogo.gif" ALT="Oracle Corporation and/or its affiliates" BORDER=0 WIDTH=100 HEIGHT=29><BR>
<FONT SIZE="+1"> <i>Java Technology</i></FONT> </TD></TR>
</TABLE> 

<!-- STATIC FOOTER -->

</body></html>
