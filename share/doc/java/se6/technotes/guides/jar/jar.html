<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>JAR File Specification</title><link rel="stylesheet" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<table width="100%"><tr><td valign="bottom" align="left"><img src="../../../images/javalogo.gif"></td><td valign="bottom" align="right"><a href="../../../index.html"><font size="-1">Documentation Contents</font></a></td></tr></table><table>
<tr>
<td>

<h1>JAR File Specification</h1>

</td>
<td width="60"></td>
</tr>
</table>
<h2><b>Contents</b></h2>
<ul>
<li><a href="#Intro">Introduction</a></li>
<li><a href="#The%20META-INF%20directory">The
META-INF&nbsp;directory</a></li>
<li><a href="#Name-Value%20pairs%20and%20Sections">Name-Value pairs
and Sections</a></li>
<li><a href="#JAR%20Manifest">JAR Manifest</a></li>
<li style="list-style: none">
<ul>
<li><a href="#Manifest-Overview">Overview</a></li>
<li><a href="#Manifest%20Specification">Manifest
Specification</a></li>
<li><a href="#Main%20Attributes">Main Attributes</a></li>
<li><a href="#Per-Entry%20Attributes">Per-Entry Attributes</a></li>
</ul>
</li>
<li><a href="#Signed%20JAR%20File">Signed JAR file</a></li>
<li style="list-style: none">
<ul>
<li><a href="#SignedJar-Overview">Overview</a></li>
<li><a href="#Signature%20File">Signature File</a></li>
<li style="list-style: none">
<ul>
<li><a href="#Signature%20Validation">Signature validation</a></li>
<li><a href="#The%20Magic%20Attribute">The Magic Attribute</a></li>
</ul>
</li>
<li><a href="#Digital%20Signatures">Digital Signatures</a></li>
</ul>
</li>
<li><a href=
"#Notes%20on%20Manifest%20and%20Signature%20Files">Notes on
Manifest and Signature Files</a></li>
<li><a href="#JARIndex">JAR Index</a></li>
<li style="list-style: none">
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Index%20File%20Specification">Index File
Specification</a></li>
<li><a href="#Backward%20Compatibility">Backward
Compatibility</a></li>
</ul>
</li>
<li><a href="#Service%20Provider">Service Provider</a></li>
<li style="list-style: none">
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Provider%20Configuration%20File">Provider
Configuration File</a></li>
<li><a href="#Example">Example</a></li>
</ul>
</li>
<li><a href="#API%20Details">API&nbsp;Details</a></li>
<li><a href="#See%20Also">See Also</a></li>
</ul>
<h2><a name="Intro" id="Intro"></a><b>Introduction</b></h2>
JAR file is a file format based on the popular ZIP file format and
is used for aggregating many files into one. A&nbsp; JAR file is
essentially a zip file that contains an optional META-INF
directory. A JAR file can be created by the command-line <a href=
"../../tools/windows/jar.html">jar</a> tool, or by using the&nbsp;
<tt><a href=
"../../../api/java/util/jar/package-summary.html">java.util.jar</a></tt>
API in the Java platform. There is no restriction on the name of a
JAR file, it can be any legal file name on a particular platform.
<p>In many cases, JAR files are not just simple archives of java
classes files and/or resources. They are used as building blocks
for applications and extensions. The META-INF directory, if it
exists, is used to store package and extension configuration data,
including security, versioning, extension and services.</p>
<h2><a name="The META-INF directory"></a>The META-INF
directory</h2>
The following files/directories in the META-INF directory are
recognized and interpreted by the Java 2 Platform to configure
applications, extensions, class loaders and services:
<ul>
<li><tt>MANIFEST.MF</tt></li>
</ul>
The manifest file that is used to define extension and package
related data.
<ul>
<li><tt>INDEX.LIST</tt></li>
</ul>
This file is generated by the new "<tt>-i"</tt> option of the jar
tool, which contains location information for packages defined in
an application or extension.&nbsp; It is part of the JarIndex
implementation and used by class loaders to speed up their class
loading process.
<ul>
<li><tt>x.SF</tt></li>
</ul>
The signature file for the JAR file.&nbsp; 'x' stands for the base
file name.
<ul>
<li><tt>x.DSA</tt></li>
</ul>
The signature block file associated with the signature file with
the same base file name. This file stores the digital signature of
the corresponding signature file.
<ul>
<li><tt>services/</tt></li>
</ul>
This directory stores all the service provider configuration files.
<h1><a name="Name-Value pairs and Sections"></a>Name-Value pairs
and Sections</h1>
Before we go to the details of the contents of the individual
configuration files, some format convention needs to be defined. In
most cases, information contained within the manifest file and
signature files is represented as so-called "name: value" pairs
inspired by the RFC822 standard.&nbsp; We also call these pairs
headers or attributes.
<p>Groups of name-value pairs are known as a "section". Sections
are separated from other sections by empty lines.</p>
<p>Binary data of any form is represented as base64. Continuations
are required for binary data which causes line length to exceed 72
bytes. Examples of binary data are digests and signatures.</p>
<p>Implementations shall support header values of up to 65535
bytes.</p>
<p>All the specifications in this document use the same grammar in
which terminal symbols are shown in fixed width font and
non-terminal symbols are shown in italic type face.</p>
<h3><a name="Section-Specification" id=
"Section-Specification"></a>Specification:</h3>
&nbsp;
<i>section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*header +newline</i><br />
<i>&nbsp; nonempty-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +header
+newline</i><br />
<i>&nbsp;
newline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;
<i>header:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name</i> <tt>:</tt> <i>value</i><br />
<i>&nbsp;
name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum *headerchar</i><br />
<i>&nbsp;
value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
SPACE *<i>otherchar newline *continuation</i><br />
&nbsp;
<i>continuation:</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SPACE <i>*otherchar newline</i><br />
&nbsp;
<i>alphanum</i>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<tt>A-Z</tt>} | {<tt>a-z</tt>} | {<tt>0-9</tt>}<br />
&nbsp;
<i>headerchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum</i> | <tt>-</tt> | <tt>_</tt><br />
&nbsp;
<i>otherchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any UTF-8 character except</i> <tt>NUL, CR</tt> <i>and</i>
<tt>LF</tt>
<p><i>; Also: To prevent mangling of files sent via straight
e-mail, no</i><br />
<i>; header will start with the four letters "From".</i><br />
&nbsp;</p>
<p>Non-terminal symbols defined in the above specification will be
referenced in the following specifications.</p>
<h1><a name="JAR Manifest"></a>JAR Manifest</h1>
<h3><a name="Manifest-Overview" id=
"Manifest-Overview"></a>Overview</h3>
A JAR file manifest consists of a main section followed by a list
of sections for individual JAR file entries, each separated by a
newline. Both the main section and individual sections follow the
section syntax specified above. They each have their own specific
restrictions and rules.
<p>The main section contains security and configuration information
about the JAR file itself, as well as the application or extension
that this JAR file is a part of. It also defines main attributes
that apply to every individual manifest entry.&nbsp; No attribute
in this section can have its name equal to&nbsp; "<tt>Name</tt>".
This section is terminated by an empty line.</p>
<p>The individual sections define various attributes for packages
or files contained in this JAR file. Not all files in the JAR file
need to be listed in the manifest as entries, but all files which
are to be signed must be listed. The manifest file itself must not
be listed.&nbsp; Each section must start with an attribute with the
name as "<tt>Name</tt>", and the value must be a relative path to
the file, or an absolute URL referencing data outside the
archive.</p>
<p>If there are multiple individual sections for the same file
entry, the attributes in these sections are merged. If a certain
attribute have different values in different sections, the last one
is recognized.</p>
<p>Attributes which are not understood are ignored. Such attributes
may include implementation specific information used by
applications.</p>
<h3><a name="Manifest Specification"></a>Manifest
Specification:</h3>
&nbsp;
<i>manifest-file:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
main-section newline *individual-section</i><br />
<i>&nbsp;
main-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info newline *main-attribute</i><br />
<i>&nbsp;
version-info:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>Manifest-Version :</tt> <i>version-number</i><br />
&nbsp; <i>version-number
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{</i><tt>.</tt><i>digit+}*</i><br />
&nbsp;
<i>main-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate main attribute) newline</i><br />
<i>&nbsp;
individual-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>Name :</tt> <i>value</i> <i>newline
*perentry-attribute</i><br />
<i>&nbsp;
perentry-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate perentry attribute) newline</i><br />
<i>&nbsp; newline
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;&nbsp;
<i>digit:</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>{0-9}&nbsp;</tt>
<p>In the above specification, attributes that can appear in the
main section are referred to as main attributes, whereas attributes
that can appear in individual sections are referred to as per-entry
attributes. Certain attributes can appear both in the main section
and the individual sections, in which case the per-entry attribute
value overrides the main attribute value for the specified entry.
The two types of attributes are defined as follows.<br />
&nbsp;</p>
<h3><a name="Main Attributes"></a>Main Attributes</h3>
Main attributes are the attributes that are present in the main
section of the manifest. They fall into the following different
groups:
<ul>
<li>general main attributes</li>
</ul>
<ul>
<li style="list-style: none">
<ul>
<li>Manifest-Version:</li>
</ul>
<ul>
<li style="list-style: none">Defines the manifest file version. The
value is a legitimate version number, as described in the above
spec.<br />
&nbsp;</li>
<li>Created-By:</li>
<li style="list-style: none"><br />
Defines the version and the vendor of the java implementation on
top of which this manifest file is generated. This attribute is
generated by the <tt>jar</tt> tool.<br />
&nbsp;</li>
<li>Signature-Version:</li>
<li style="list-style: none"><br />
Defines the signature version of the jar file. The value should be
a valid <i>version-number</i> string.<br />
&nbsp;</li>
<li>Class-Path :</li>
<li style="list-style: none"><br />
The value of this attribute specifies the relative URLs of the
extensions or libraries that this application or extension needs.
URLs are separated by one or more spaces. The application or
extension class loader uses the value of this attribute to
construct its internal search path.<br />
&nbsp;</li>
</ul>
</li>
<li>attribute defined for stand-alone applications</li>
<li style="list-style: none">This attribute is used by stand-alone
applications that are bundled into executable jar files which can
be invoked by the java runtime directly by running "<tt>java -jar
x.jar</tt>".
<ul>
<li>Main-Class :</li>
<li style="list-style: none"><br />
The value of this attribute defines the relative path of the main
application class which the launcher will load at startup time. The
value must <em>not</em> have the <tt>.class</tt> extension appended
to the class name.</li>
</ul>
</li>
</ul>
<ul>
<li>attributes defined for applets</li>
<li style="list-style: none">These attributes is used by an applet
which is bundled into JAR&nbsp;files to define requirements,
version and location information for the extensions which this
applet depends on. (see&nbsp; <a href=
"../extensions/versioning.html">Extension Versioning</a> ).&nbsp;
<ul>
<li>Extension-List:</li>
<li style="list-style: none"><br />
This attribute indicates the extensions that are needed by the
applet. Each extension listed in this attribute will have a set of
additional attributes that the applet uses to specify which version
and vendor of the extension it requires.<br />
&nbsp;</li>
<li>&lt;extension&gt;-Extension-Name :</li>
<li style="list-style: none"><br />
This attribute is the unique name of the extension. The Java
Plug-in will compare the value of this attribute with the
Extension-Name attribute in the manifests of installed extensions
to determine if the extension is installed.<br />
&nbsp;</li>
<li>&lt;extension&gt;-Specification-Version</li>
<li style="list-style: none"><br />
This attribute specifies the minimum extension specification
version that is required by the applet. The Java Plug-in will
compare the value of this attribute with the Specification-Version
attribute of the installed extension to determine if the extension
is up to date.<br />
&nbsp;</li>
<li>&lt;extension&gt;-Implementation-Version</li>
<li style="list-style: none"><br />
This attritute specifies the minimum extension implementation
version number that is required by the applet. The Java Plug-in
will compare the value of this attribute with the
Implementation-Version attribute of the installed extension to see
if a more recent implementation needs to be downloaded.<br />
&nbsp;</li>
<li>&lt;extension&gt;-Implementation-Vendor-Id</li>
<li style="list-style: none"><br />
This attribute can be used to identify the vendor of an extension
implementation if the applet requires an implementation from a
specific vendor. The Java Plug-in will compare the value of this
attribute with the Implementation-Vendor-Id attribute of the
installed extension.<br />
&nbsp;</li>
<li>&lt;extension&gt;-Implementation-URL</li>
<li style="list-style: none"><br />
This attribute specifies a URL that can be used to obtain the most
recent version of the extension if the required version is not
already installed.<br />
&nbsp;</li>
</ul>
</li>
<li>attribute defined for extension identification</li>
<li style="list-style: none">This attribute is used by extensions
to define their unique identity.
<ul>
<li>Extension-Name:</li>
<li style="list-style: none">This attribute specifies a name for
the extension contained in the Jar file. The name should be a
unique identifier such as the name of the main package comprising
the extension.</li>
</ul>
&nbsp;</li>
<li>attributes defined for extension and&nbsp; package <a href=
"../versioning/index.html">versioning</a>&nbsp; and <a href=
"../extensions/spec.html#sealing">sealing</a> information</li>
<li style="list-style: none">These attributes define features of
the extension which the JAR file is a part of. The value of these
attributes apply to all the packages in the JAR&nbsp;file, but can
be overridden by per-entry attributes.&nbsp;
<ul>
<li>Implementation-Title :</li>
<li style="list-style: none">The value is a string that defines the
title of the extension implementation.&nbsp;</li>
<li>Implementation-Version :</li>
<li style="list-style: none"><br />
The value is a string that defines the version of the extension
implementation.<br />
&nbsp;</li>
<li>Implementation-Vendor :</li>
<li style="list-style: none"><br />
The value is a string that defines the organization that maintains
the extension implementation.<br />
&nbsp;</li>
<li>Implementation-Vendor-Id :</li>
<li style="list-style: none"><br />
The value is a string id that uniquely defines the organization
that maintains the&nbsp; extension implementation.<br />
&nbsp;</li>
<li>Implementation-URL :</li>
<li style="list-style: none"><br />
This attribute defines the URL from which the extension
implementation can be downloaded from.<br />
&nbsp;</li>
<li>&nbsp;Specification-Title :</li>
<li style="list-style: none"><br />
The value is a string that defines the title of the extension
specification.<br />
&nbsp;</li>
<li>Specification-Version :</li>
<li style="list-style: none"><br />
The value is a string that defines the version of the extension
specification.<br />
&nbsp;</li>
<li>Specification-Vendor :</li>
<li style="list-style: none"><br />
The value is a string that defines the organization that maintains
the extension specification.</li>
</ul>
</li>
</ul>
<div style="margin-left: 2em">
<ul>
<li>Sealed :</li>
<li style="list-style: none"><br />
This attribute defines whether this JAR file is sealed or not. The
value can be either "true" or "false", case is ignored. If it is
set to "true", then all the packages in the JAR file are defaulted
to be sealed, unless they are defined otherwise individually.</li>
</ul>
</div>
<h3><a name="Per-Entry Attributes"></a>Per-Entry Attributes</h3>
Per-entry attributes apply only to the individual JAR file entry to
which the manifest entry is associated with.&nbsp; If the same
attribute also appeared in the main section, then the value of the
per-entry attribute overwrites the main attribute's value. For
example, if JAR file a.jar has the following manifest content:
<div style="margin-left: 2em"><tt>Manifest-Version: 1.0</tt><br />
<tt>Created-By: 1.2 (Sun Microsystems Inc.)</tt><br />
<tt>Sealed: true</tt>
<p><tt>Name: foo/bar/</tt><br />
<tt>Sealed: false</tt></p>
</div>
It means that all the packages archived in a.jar are sealed, except
that package foo.bar is not.
<p>The per-entry attributes fall into the following groups:</p>
<ul>
<li>attributes defined for file contents:</li>
<li style="list-style: none">
<ul>
<li>Content-Type :</li>
<li style="list-style: none"><br />
This attribute can be used to specify the MIME type and subtype of
data for a specific file entry in the JAR&nbsp;file. The value
should be a string in the form of <i>type/subtype.</i> For example
"image/bmp" is an image type with a subtype of bmp (representing
bitmap). This would indicate the file entry as an image with the
data stored as a bitmap. RFC <a href=
"ftp://www.ietf.org/rfc/rfc1521.txt">1521</a> and <a href=
"ftp://www.ietf.org/rfc/rfc1522.txt">1522</a> discuss and define
the MIME types definition.</li>
</ul>
</li>
</ul>
<ul>
<li>attributes defined for package versioning and sealing
information:</li>
<li style="list-style: none">
<p>These are the same set of attributes defined above as main
attributes that defines the extension package versioning and
sealing information. When used as per-entry attributes, these
attributes overwrites the main attributes but only apply to the
individual file specified by the manifest entry.<br />
&nbsp;</p>
</li>
<li>attribute defined for beans objects:</li>
<li style="list-style: none">
<ul>
<li>Java-Bean:</li>
<li style="list-style: none"><br />
Defines whether the specific jar file entry is a Java <a href=
"http://java.sun.com/products/javabeans/docs/spec.html">Beans</a>
object or not. The value should be either "true" or "false", case
is ignored.<br />
&nbsp;</li>
</ul>
</li>
<li>attributes defined for signing:</li>
<li style="list-style: none"><br />
These attributes are used for signing and verifying purposes. More
details here.
<ul>
<li>x-Digest-y:</li>
<li style="list-style: none"><br />
The name of this attribute specifies the name of the digest
algorithm used to compute the digest value for the corresponding
jar file entry. The value of this attribute stores the actual
digest value. The prefix 'x' specifies the algorithm name and the
optional suffix 'y'&nbsp; indicates to which language the digest
value should be verified against.</li>
<li>Magic:</li>
<li style="list-style: none"><br />
This is an optional attribute that can be used by applications to
indicate how verifier should compute the digest value contained in
the manifest entry.&nbsp; The value of this attribute is a set of
comma separated context specific strings. Detailed description is
here.</li>
</ul>
</li>
</ul>
<h1><a name="Signed JAR File"></a>Signed JAR File</h1>
<h3><a name="SignedJar-Overview" id=
"SignedJar-Overview"></a>Overview</h3>
A JAR file can be signed by using the command line <a href=
"../security/SecurityToolsSummary.html">jarsigner</a> tool or
directly through the <code>java.security</code> API. Every file
entry, including non-signature related files in the
<code>META-INF</code> directory, will be signed if the JAR file is
signed by the jarsigner tool. The signature related files are:
<ul>
<li><code>META-INF/MANIFEST.MF</code></li>
<li><code>META-INF/*.SF</code></li>
<li><code>META-INF/*.DSA</code></li>
<li><code>META-INF/*.RSA</code></li>
<li><code>META-INF/SIG-*</code></li>
</ul>
Note that if such files are located in <code>META-INF</code>
subdirectories, they are not considered signature-related.
Case-insensitive versions of these filenames are reserved and will
also not be signed.
<p>Subsets of a JAR file can be signed by using the
<code>java.security</code> API. A signed JAR file is exactly the
same as the original JAR file, except that its manifest is updated
and two additional files are added to the <code>META-INF</code>
directory: a signature file and a signature block file. When
jarsigner is not used, the signing program has to construct both
the signature file and the signature block file.</p>
<p>For every file entry signed in the signed JAR file, an
individual manifest entry is created for it as long as it does not
already exist in the manifest. Each manifest entry lists one or
more digest attribute and an optional <a href=
"#The%20Magic%20Attribute">Magic attribute</a>.</p>
<h3><a name="Signature File"></a>Signature File</h3>
Each signer is represented by a signature file with extension
<code>.SF</code>. The major part of the file is similar to the
manifest file. It consists of a main section which includes
information supplied by the signer but not specific to any
particular jar file entry. The main section entry,
<code>x-Digest-Manifest-Main-Attributes</code> (where
<code>x</code> is a digest algorithm), contains the digest value
for the main attributes of the manifest.
<p>The main section is followed by a list of individual entries
whose names must also be present in the manifest file. Each
individual entry must contain at least the digest of its
corresponding entry in the manifest file.</p>
<p>Paths or URLs appearing in the manifest file but not in the
signature file are not used in the calculation.</p>
<h3><a name="Signature Validation"></a>Signature Validation</h3>
The signature over the signature file is first verified when the
manifest is first parsed. For efficiency, this verification can be
remembered. Note that this verification only validates the
signature directions themselves, not the actual archive files.
<p>The manifest main attributes are also verified when verification
information is available in the signature file. If an
<code>x-Digest-Manifest-Main-Attributes</code> entry exists in the
signature file, it is compared against a digest calculated against
the main attributes in the manifest file. If this calculation
fails, then jar validation fails. This decision can be remembered,
for efficiency. If an
<code>x-Digest-Manifest-Main-Attributes</code> entry does not exist
in the signature file, its nonexistence does not affect jar
validation and the manifest main attributes are not verified.</p>
<p>To validate a file, a digest value in the signature file is
compared against a digest calculated against the corresponding
entry in the manifest file. Then, a digest value in the manifest
file is compared against a digest calculated against the actual
data referenced in the "<code>Name:</code>" attribute, which
specifies either a relative file path or URL.</p>
<p>Example manifest file:</p>
<blockquote>
<pre>
Manifest-Version: 1.0
Created-By: 1.3 (Sun Microsystems, Inc)
 
Name: common/class1.class
MD5-Digest: (base64 representation of MD5 digest)
 
Name: common/class2.class
MD5-Digest: (base64 representation of MD5 digest)
SHA-Digest: (base64 representation of SHA digest)
</pre></blockquote>
The corresponding signature file would be:
<blockquote>
<pre>
Signature-Version: 1.0
MD5-Digest-Manifest-Main-Attributes: (base64 representation of MD5 digest)
 
Name: common/class1.class
MD5-Digest: (base64 representation of MD5 digest)
 
Name: common/class2.class
MD5-Digest: (base64 representation of MD5 digest)
</pre></blockquote>
<br />
<h3><a name="The Magic Attribute"></a>The Magic Attribute</h3>
Another requirement to validate the signature on a given manifest
entry is that the verifier understand the value or values of the
Magic key-pair value in that entry's manifest entry.
<p>The Magic attribute is optional but it is required that a parser
understand the value of an entry's Magic key if it is verifying
that entry's signature.</p>
<p>The value or values of the Magic attribute are a set of
comma-separated context-specific strings. The spaces before and
after the commas are ignored. Case is ignored. The exact meaning of
the magic attributes is application specific. These values indicate
how to compute the hash value contained in the manifest entry, and
are therefore crucial to the proper verification of the signature.
The keywords may be used for dynamic or embedded content, multiple
hashes for multilingual documents, etc.</p>
<p>Here are two examples of the potential use of Magic attribute in
the manifest file:</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>Name: http://www.scripts.com/index#script1</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest: (base64
representation of SHA hash)</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magic: JavaScript,
Dynamic</tt></p>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name:
http://www.tourist.com/guide.html</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest: (base64
representation of SHA hash)</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest-French:
(base64 representation of SHA hash)</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest-German:
(base64 representation of SHA hash)</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magic:
Multilingual</tt></p>
<p>In the first example, these Magic values may indicate that the
result of an http query is the script embedded in the document, as
opposed to the document itself, and also that the script is
generated dynamically. These two pieces of information indicate how
to compute the hash value against which to compare the manifest's
digest value, thus comparing a valid signature.</p>
<p>In the second example, the Magic value indicates that the
document retrieved may have been content-negotiated for a specific
language, and that the digest to verify against is dependent on
which language the document retrieved is written in.</p>
<h2><a name="Digital Signatures"></a>Digital Signatures</h2>
A digital signature is a signed version of the <code>.SF</code>
signature file. These are binary files not intended to be
interpreted by humans.
<p>Digital signature files have the same filenames as the .SF files
but different extensions. The extension varies depending on the
type of digital signature.</p>
<blockquote>
<pre>
.RSA      (PKCS7 signature, MD5 + RSA)
.DSA      (PKCS7 signature, DSA)
</pre></blockquote>
Digital signature files for signature algorithms not listed above
must reside in the <code>META-INF</code> directory and have the
prefix "<code>SIG-</code>". The corresonding signature file
(<code>.SF</code> file) must also have the same prefix.
<p>For those formats that do not support external signed data, the
file shall consist of a signed copy of the <code>.SF</code> file.
Thus some data may be duplicated and a verifier should compare the
two files.</p>
<p>Formats that support external data either reference the
<code>.SF</code> file, or perform calculations on it with implicit
reference.</p>
<p>Each <code>.SF</code> file may have multiple digital signatures,
but those signatures should be generated by the same legal
entity.</p>
<p>File name extensions may be 1 to 3 <i>alphanum</i> characters.
Unrecognized extensions are ignored.</p>
<h1><a name="Notes on Manifest and Signature Files"></a>Notes on
Manifest and Signature Files</h1>
Following is a list of additional restrictions and rules that apply
to manifest and signature files.
<ul>
<li>Before parsing:</li>
<li style="list-style: none"><br />
If the last character of the file is an EOF character (code 26),
the EOF is treated as whitespace. Two newlines are appended (one
for editors that don't put a newline at the end of the last line,
and one so that the grammar doesn't have to special-case the last
entry, which may not have a blank line after it).</li>
</ul>
<ul>
<li>Attributes:</li>
<li style="list-style: none"><br />
In all cases for all sections, attributes which are not understood
are ignored.
<p>Attribute names are case insensitive. Programs which generate
manifest and signature files should use the cases shown in this
specification however.</p>
<p>Attribute names cannot be repeated within a section.</p>
</li>
</ul>
<ul>
<li>Versions:</li>
<li style="list-style: none"><br />
Manifest-Version and Signature-Version must be first, and in
exactly that case (so that they can be recognized easily as magic
strings). Other than that, the order of attributes within a main
section is not significant.<br />
&nbsp;</li>
<li>Ordering:</li>
<li style="list-style: none"><br />
The order of individual manifest entries is not significant.
<p>The order of individual signature entries is not significant,
except that the digests that get signed are in that order.</p>
</li>
</ul>
<ul>
<li>Line length:</li>
<li style="list-style: none"><br />
No line may be longer than 72 bytes (not characters), in its
UTF8-encoded form. If a value would make the initial line longer
than this, it should be continued on extra lines (each starting
with a single SPACE).<br />
&nbsp;</li>
<li>Errors:</li>
<li style="list-style: none"><br />
If a file cannot be parsed according to this spec, a warning should
be output, and none of the signatures should be trusted.<br />
&nbsp;</li>
<li>Limitations:</li>
<li style="list-style: none"><br />
Because header names cannot be continued, the maximum length of a
header name is 70 bytes (there must be a colon and a SPACE after
the name).
<p>NUL, CR, and LF can't be embedded in header values, and NUL, CR,
LF and ":" can't be embedded in header names.</p>
<p>Implementations should support 65535-byte (not character) header
values, and 65535 headers per file. They might run out of memory,
but there should not be hard-coded limits below these values.</p>
</li>
</ul>
<ul>
<li>Signers:</li>
<li style="list-style: none"><br />
It is technically possible that different entities may use
different signing algorithms to share a single signature file. This
violates the standard, and the extra signature may be ignored.</li>
</ul>
<ul>
<li>Algorithms:</li>
<li style="list-style: none"><br />
No digest algorithm or signature algorithm is mandated by this
standard. However, at least one of MD5 and SHA&nbsp;digest
algorithm must be supported.</li>
</ul>
<h2><a name="JARIndex" id="JARIndex"></a>JAR Index</h2>
<h3><a name="Overview" id="Overview"></a>Overview</h3>
Since 1.3, JarIndex is introduced to optimize the class searching
process of class loaders for network applications, especially
applets. Originally, an applet class loader uses a simple linear
search algorithm to search each element on its internal search
path, which is constructed from the "ARCHIVE" tag or the
"Class-Path" main attribute. The class loader downloads and opens
each element in its search path, until the class or resource is
found. If the class loader tries to find a nonexistent resource,
then all the jar files within the application or applet will have
to be downloaded. For large network applications and applets this
could result in slow startup, sluggish response and wasted network
bandwidth. The JarIndex mechanism collects the contents of all the
jar files defined in an applet and stores the information in an
index file in the first jar file on the applet's class path. After
the first jar file is downloaded, the applet class loader will use
the collected content information for efficient downloading of jar
files.
<p>The existing <tt>jar</tt> tool is enhanced to be able to examine
a list of jar files and generate directory information as to which
classes and resources reside in which jar file. This directory
information is stored in a simple text file named
<tt>INDEX.LIST</tt> in the <tt>META-INF</tt> directory of the root
jar file. When the classloader loads the root jar file,&nbsp; it
reads the <tt>INDEX.LIST</tt> file and uses it to construct a hash
table of mappings from file and package names to lists of jar file
names. In order to find a class or a resource, the class loader
queries the hashtable to find the proper jar file and then
downloads it if necessary.</p>
<p>Once the class loader finds a <tt>INDEX.LIST</tt> file in a
particular jar file, it always trusts the information listed in it.
If a mapping is found for a particular class, but the class loader
fails to find it by following the link, an InvalidJarIndexException
is thrown. When this occurs, the application developer should rerun
the <tt>jar</tt> tool on the extension to get the right information
into the index file.</p>
<p>To prevent adding too much space overhead to the application and
to speed up the construction of the in-memory hash table, the
INDEX.LIST file is kept as small as possible. For classes with
non-null package names, mappings are recorded at the package level.
Normally one package name is mapped to one jar file, but if a
particular package spans more than one jar file, then the mapped
value of this package will be a list of jar files. For resource
files with non-empty directory prefixes, mappings are also recorded
at the directory level.&nbsp; Only for classes with null package
name, and resource files which reside in the root directory, will
the mapping be recorded at the individual file level.</p>
<h3><a name="Index File Specification"></a>Index File
Specification</h3>
The <tt>INDEX.LIST</tt> file contains one or more sections each
separated by a single blank line. Each section defines the content
of a particular jar file, with a header defining the jar file path
name, followed by a list of package or file names, one per
line.&nbsp; All the jar file paths are relative to the code base of
the root jar file. These path names are resolved in the same way as
the current extension mechanism does for bundled extensions.
<p>The UTF-8 encoding is used to support non ASCII characters in
file or package names in the index file.<br />
&nbsp;</p>
<h4>Specification</h4>
&nbsp;&nbsp;&nbsp; <i>index file
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info blankline section*</i><br />
<i>&nbsp;&nbsp;&nbsp; version-info
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>JarIndex-Version:</tt> <i>version-number</i><br />
<i>&nbsp;&nbsp;&nbsp; version-number
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{.digit+}*</i><br />
<i>&nbsp;&nbsp;&nbsp; section
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
body blankline</i><br />
<i>&nbsp;&nbsp;&nbsp; body
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
header name*</i><br />
<i>&nbsp;&nbsp;&nbsp; header
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+</i><tt>.jar</tt> <i>newline</i><br />
<i>&nbsp;&nbsp;&nbsp; name
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+ newline</i><br />
<i>&nbsp;&nbsp;&nbsp; char
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any valid Unicode character except</i> <tt>NULL, CR</tt>
<i>and</i><tt>LF</tt><br />
&nbsp;&nbsp;&nbsp;
<i>blankline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
newline newline</i><br />
<i>&nbsp;&nbsp;&nbsp; newline
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;&nbsp;&nbsp;
<i>digit:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<tt>0-9</tt>}<br />
&nbsp;<br />
The <tt>INDEX.LIST</tt> file is generated by running <tt>jar
-i.</tt> See the <a href="../../tools/windows/jar.html">jar</a> man
page for more details.
<h3><a name="Backward Compatibility"></a>Backward
Compatibility</h3>
The new class loading scheme is totally backward compatible with
applications developed on top of the current extension
mechanism.&nbsp; When the class loader loads the first jar file and
an <tt>INDEX.LIST</tt> file is found in the <tt>META-INF</tt>
directory, it would construct the index hash table and use the new
loading scheme for the extension. Otherwise, the class loader will
simply use the original linear search algorithm.
<h2><a name="Service Provider"></a>Service Provider</h2>
<h3><a name="Overview" id="Overview"></a>Overview</h3>
Files in the <tt>META-INF/services</tt> directory are service
provider configuration files. A service is a well-known set of
interfaces and (usually abstract) classes. A service provider is a
specific implementation of a service. The classes in a provider
typically implement the interfaces and subclass the classes defined
in the service itself. Service providers may be installed in an
implementation of the Java platform in the form of extensions, that
is, jar files placed into any of the usual extension directories.
Providers may also be made available by adding them to the applet
or application class path or by some other platform-specific means.
<p>A service is represented by an abstract class. A provider of a
given service contains one or more concrete classes that extend
this service class with data and code specific to the provider.
This provider class will typically not be the entire provider
itself but rather a proxy that contains enough information to
decide whether the provider is able to satisfy a particular request
together with code that can create the actual provider on demand.
The details of provider classes tend to be highly service-specific;
no single class or interface could possibly unify them, so no such
class has been defined. The only requirement enforced here is that
provider classes must have a zero-argument constructor so that they
may be instantiated during lookup.<br />
&nbsp;</p>
<h3><a name=
"Provider Configuration File"></a>Provider-Configuration File</h3>
A service provider identifies itself by placing a
provider-configuration file in the resource directory
<tt>META-INF/services</tt>. The file's name should consist of the
fully-qualified name of the abstract service class. The file should
contain a newline-separated list of unique concrete provider-class
names. Space and tab characters, as well as blank lines, are
ignored. The comment character is '#' (0x23); on each line all
characters following the first comment character are ignored. The
file must be encoded in UTF-8.<br />
&nbsp;
<h3><a name="Example" id="Example"></a>Example</h3>
Suppose we have a service class named java.io.spi.CharCodec. It has
two abstract methods:
<p>&nbsp;&nbsp;&nbsp; <tt>public abstract CharEncoder
getEncoder(String encodingName);</tt><br />
<tt>&nbsp; public abstract CharDecoder getDecoder(String
encodingName);</tt></p>
<p>Each method returns an appropriate object or null if it cannot
translate the given encoding. Typical CharCodec providers will
support more than one encoding.</p>
<p>If sun.io.StandardCodec is a provider of the CharCodec service
then its jar file would contain the file
<tt>META-INF/services/java.io.spi.CharCodec</tt>. This file would
contain the single line:</p>
<p>&nbsp;&nbsp; <tt>sun.io.StandardCodec&nbsp;&nbsp;&nbsp; #
Standard codecs for the platform</tt></p>
<p>To locate an encoder for a given encoding name, the internal I/O
code would do something like this:</p>
<p>&nbsp;&nbsp; <tt>CharEncoder getEncoder(String encodingName)
{</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator ps =
Service.providers(CharCodec.class);</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ps.hasNext())
{</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CharCodec cc = (CharCodec)ps.next();</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CharEncoder ce = cc.getEncoder(encodingName);</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(ce != null)</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return ce;</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt><br />
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;</tt><br />
<tt>&nbsp;&nbsp; }</tt><br />
&nbsp;</p>
<p>The provider-lookup mechanism always executes in the security
context of the caller. Trusted system code should typically invoke
the methods in this class from within a privileged security
context.</p>
<p>&nbsp;</p>
<h2><a name="API Details"></a>API Details</h2>
Package <a href=
"../../../api/java/util/jar/package-summary.html">java.util.jar</a>
<h2><a name="See Also"></a>See Also</h2>
Package <a href=
"../../../api/java/security/package-summary.html">java.security</a><br />

Package <a href=
"../../../api/java/util/zip/package-summary.html">java.util.zip</a>
<!-- Body text ends here -->
 
<!-- ============================================================== -->

<HR>
<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN="TOP"><TD><P><FONT SIZE="-2">
<A HREF=../../../legal/cpyr.html>Copyright &#169;</A> 1993, 2011, Oracle and/or its affiliates. All rights reserved.</FONT></P><FONT SIZE="-1"> Please send comments using this <a href=http://download.oracle.com/javase/feedback.html>Feedback</a> page.</FONT> </TD>
<TD ALIGN=RIGHT> <IMG SRC="../../../images/oraclelogo.gif" ALT="Oracle Corporation and/or its affiliates" BORDER=0 WIDTH=100 HEIGHT=29><BR>
<FONT SIZE="+1"> <i>Java Technology</i></FONT> </TD></TR>
</TABLE> 

<!-- STATIC FOOTER -->

</body>
</html>
