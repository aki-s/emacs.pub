<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Concurrency Utilities Overview</title><link rel="stylesheet" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<table width="100%"><tr><td valign="bottom" align="left"><img src="../../../images/javalogo.gif"></td><td valign="bottom" align="right"><a href="../../../index.html"><font size="-1">Documentation Contents</font></a></td></tr></table><table width="100%" summary="layout" border="0">
<tbody>
<tr>
<td>

<h1>Concurrency Utilities<br />
Overview</h1>

</td>
</tr>
</tbody>
</table>
<!-- Body text begins here -->
<h3>Introduction</h3>
<p>The Java 2 platform includes a new package of <i>concurrency
utilities</i>. These are classes which are designed to be used as
building blocks in building concurrent classes or applications.
Just as the Collections Framework greatly simplified the
organization and manipulation of in-memory data by providing
implementations of commonly used data structures, the Concurrency
Utilities aims to simplify the development of concurrent classes by
providing implementations of building blocks commonly used in
concurrent designs. The Concurrency Utilities include a
high-performance, flexible thread pool; a framework for
asynchronous execution of tasks; a host of collection classes
optimized for concurrent access; synchronization utilities such as
counting semaphores; atomic variables; locks; and condition
variables.</p>
<p>Using the Concurrency Utilities, instead of developing
components such as thread pools yourself, offers a number of
advantages:</p>
<ul>
<li><strong>Reduced programming effort.</strong> It is far easier
to use a standard class than to develop it yourself.</li>
<li><strong>Increased performance.</strong> The implementations in
the Concurrency Utilities were developed and peer-reviewed by
concurrency and performance experts; these implementations are
likely to be faster and more scalable than a typical
implementation, even by a skilled developer.</li>
<li><strong>Increased reliability.</strong> Developing concurrent
classes is difficult -- the low-level concurrency primitives
provided by the Java language (<code>synchronized</code>,
<code>volatile</code>, <code>wait()</code>, <code>notify()</code>,
and <code>notifyAll()</code>) are difficult to use correctly, and
errors using these facilities can be difficult to detect and debug.
By using standardized, extensively tested concurrency building
blocks, many potential sources of threading hazards such as
deadlock, starvation, race conditions, or excessive context
switching are eliminated. The concurrency utilities have been
carefully audited for deadlock, starvation, and race
conditions.</li>
<li><strong>Improved maintainability.</strong> Programs which use
standard library classes are easier to understand and maintain than
those which rely on complicated, homegrown classes.</li>
<li><strong>Increased productivity.</strong> Developers are likely
to already understand the standard library classes, so there is no
need to learn the API and behavior of ad-hoc concurrent components.
Additionally, concurrent applications are far simpler to debug when
they are built on reliable, well-tested components.</li>
</ul>
<p>In short, using the Concurrency Utilities to implement a
concurrent application can help you make your program clearer,
shorter, faster, more reliable, more scalable, easier to write,
easier to read, and easier to maintain.</p>
<p>The Concurrency Utilities includes:</p>
<ul>
<li><strong>Task Scheduling Framework</strong> - The <a href=
"../../../api/java/util/concurrent/Executor.html"><code>Executor</code></a>
framework is a framework for standardizing invocation, scheduling,
execution, and control of asynchronous tasks according to a set of
execution policies. Implementations are provided that allow tasks
to be executed within the submitting thread, in a <a href=
"../../../api/java/util/concurrent/Executors.html#newSingleThreadExecutor()">
single background thread</a> (as with events in Swing), in a newly
created thread, or in a <a href=
"../../../api/java/util/concurrent/Executors.html#newFixedThreadPool(int)">
thread pool</a>, and developers can create customized
implementations of <a href=
"../../../api/java/util/concurrent/AbstractExecutorService.html">Executor</a>
supporting arbitrary execution policies. The built-in
implementations offer configurable policies such as queue length
limits and <a href=
"../../../api/java/util/concurrent/RejectedExecutionHandler.html">saturation
policy</a> which can improve the stability of applications by
preventing runaway resource consumption.</li>
<li><strong>Concurrent Collections</strong> - Several new
Collections classes have been added, including the new <a href=
"../../../api/java/util/Queue.html"><code>Queue</code></a>,
<a href="../../../api/java/util/concurrent/BlockingQueue.html"><code>
BlockingQueue</code></a> and <a href=
"../../../api/java/util/concurrent/BlockingDeque.html"><code>BlockingDeque</code></a>
interfaces, and high-performance, concurrent implementations of
<code>Map</code>, <code>List</code>, and <code>Queue</code>. See
the <a href="../collections/">Collections Framework Guide</a> for
more details.</li>
<li><strong>Atomic Variables</strong> - Classes for atomically
manipulating single variables (primitive types or references),
providing high-performance atomic arithmetic and compare-and-set
methods. The atomic variable implementations in <a href=
"../../../api/java/util/concurrent/atomic/package-summary.html#package_description">
<code>java.util.concurrent.atomic</code></a> offer higher
performance than would be available by using synchronization (on
most platforms), making them useful for implementing
high-performance concurrent algorithms as well as conveniently
implementing counters and sequence number generators.</li>
<li><strong>Synchronizers</strong> - General purpose
synchronization classes, including <a href=
"../../../api/java/util/concurrent/Semaphore.html">semaphores</a>,
<a href=
"../../../api/java/util/concurrent/Semaphore.html">mutexes</a>,
<a href=
"../../../api/java/util/concurrent/CyclicBarrier.html">barriers</a>,
<a href=
"../../../api/java/util/concurrent/CountDownLatch.html">latches</a>,
and <a href=
"../../../api/java/util/concurrent/Exchanger.html">exchangers</a>,
which facilitate coordination between threads.</li>
<li><strong>Locks</strong> - While locking is built into the Java
language via the <tt>synchronized</tt> keyword, there are a number
of inconvenient limitations to built-in monitor locks. The <a href=
"../../../api/java/util/concurrent/locks/package-summary.html#package_description">
<code>java.util.concurrent.locks</code></a> package provides a
high-performance lock implementation with the same memory semantics
as synchronization, but which also supports specifying a timeout
when attempting to acquire a lock, multiple condition variables per
lock, non-nested ("hand-over-hand") holding of multiple locks, and
support for interrupting threads which are waiting to acquire a
lock.</li>
<li><strong>Nanosecond-granularity timing</strong> - The <a href=
"../../../api/java/lang/System.html#nanoTime()"><code>System.nanoTime</code></a>
method enables access to a nanosecond-granularity time source for
making relative time measurements, and methods which accept
timeouts (such as the <a href=
"../../../api/java/util/concurrent/BlockingQueue.html#offer(E,%20long,%20java.util.concurrent.TimeUnit)">
<code>BlockingQueue.offer</code></a>, <a href=
"../../../api/java/util/concurrent/BlockingQueue.html#poll(long,%20java.util.concurrent.TimeUnit)">
<code>BlockingQueue.poll</code></a>, <a href=
"../../../api/java/util/concurrent/locks/Lock.html#tryLock(long,%20java.util.concurrent.TimeUnit)">
<code>Lock.tryLock</code></a>, <a href=
"../../../api/java/util/concurrent/locks/Condition.html#await(long,%20java.util.concurrent.TimeUnit)">
<code>Condition.await</code></a>, and <a href=
"../../../api/java/lang/Thread.html#sleep(long,%20int)"><code>Thread.sleep</code></a>)
can take timeout values in nanoseconds. The actual precision of
<code>System.nanoTime</code> is platform-dependent.</li>
</ul>

<HR>
<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN="TOP"><TD><P><FONT SIZE="-2">
<A HREF=../../../legal/cpyr.html>Copyright &#169;</A> 1993, 2011, Oracle and/or its affiliates. All rights reserved.</FONT></P><FONT SIZE="-1"> Please send comments using this <a href=http://download.oracle.com/javase/feedback.html>Feedback</a> page.</FONT> </TD>
<TD ALIGN=RIGHT> <IMG SRC="../../../images/oraclelogo.gif" ALT="Oracle Corporation and/or its affiliates" BORDER=0 WIDTH=100 HEIGHT=29><BR>
<FONT SIZE="+1"> <i>Java Technology</i></FONT> </TD></TR>
</TABLE> 

<!-- STATIC FOOTER -->

</body>
</html>
