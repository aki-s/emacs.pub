<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">



<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Function template - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/load202e.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}#toc{display:none}.editsection{display:none}

/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:4:b677bc2b5ec37947892a2d0853532528 */</style>
<script src="../../../common/load404e.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "cpp/language/function_template", "wgTitle": "cpp/language/function template", "wgCurRevisionId": 46743, "wgArticleId": 5067, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Todo with reason", "Todo without reason", "Todo no example"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_function_template action-view skin-cppreference2 cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Function template</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a> | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="line-height:1.1em;">

<tr>
<td colspan="5">  <a href="../language.html" title="cpp/language"> Language</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../header.html" title="cpp/header"> Standard library headers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../concept.html" title="cpp/concept"> Concepts</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../utility.html" title="cpp/utility"> Utilities library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../string.html" title="cpp/string"> Strings library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../container.html" title="cpp/container"> Containers library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../iterator.html" title="cpp/iterator"> Iterators library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../numeric.html" title="cpp/numeric"> Numerics library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../io.html" title="cpp/io"> Input/output library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../locale.html" title="cpp/locale"> Localizations library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../language.html" title="cpp/language"> C++ language</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr class="t-sb-list-h1">
<td colspan="5">  General topics
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="../preprocessor.html" title="cpp/preprocessor"> Preprocessor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../comment.html" title="cpp/comments" class="mw-redirect"> Comments</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../keyword.html" title="cpp/keyword"> Keywords</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="ascii.html" title="cpp/language/ascii"> ASCII chart</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="escape.html" title="cpp/language/escape"> Escape sequences</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="history.html" title="cpp/language/history"> History of C++</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Flow control
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Conditional execution statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="if.html" title="cpp/language/if"> <code>if</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="switch.html" title="cpp/language/switch"> <code>switch</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Iteration statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="for.html" title="cpp/language/for"> <code>for</code> loop</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="range-for.html" title="cpp/language/range-for"> range-<code>for</code> loop</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="while.html" title="cpp/language/while"> <code>while</code> loop</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="do.html" title="cpp/language/do"> <code>do-while</code> loop</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Jump statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="continue.html" title="cpp/language/continue"> <code>continue</code> statement</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="break.html" title="cpp/language/break"> <code>break</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="goto.html" title="cpp/language/goto"> <code>goto</code> statement</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="return.html" title="cpp/language/return"> <code>return</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Functions
</td>
</tr>

<tr>
<td colspan="5">  <a href="function.html" title="cpp/language/function"> function declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="lambda.html" title="cpp/language/lambda"> lambda function declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <strong class="selflink"> function template </strong>
</td>
</tr>

<tr>
<td colspan="5">  <a href="inline.html" title="cpp/language/inline"> inline specifier</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="except_spec.html" title="cpp/language/except spec"> exception specifications</a> <span class="t-mark">(deprecated)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="noexcept_spec.html" title="cpp/language/noexcept spec"> noexcept specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Exceptions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="throw.html" title="cpp/language/throw"> throw expression</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="try_catch.html" title="cpp/language/try catch"> try-catch block</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Namespaces
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="namespace.html" title="cpp/language/namespace"> namespace declaration</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="namespace_alias.html" title="cpp/language/namespace alias"> namespace aliases</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Types
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="types.html" title="cpp/language/types"> fundamental types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="class.html" title="cpp/language/class"> compound types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="enum.html" title="cpp/language/enum"> enumeration types</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="union.html" title="cpp/language/union"> union types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="function.html" title="cpp/language/function"> function types</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr>
<td colspan="5">  <a href="decltype.html" title="cpp/language/decltype"> <code>decltype</code> specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Specifiers
</td>
</tr>

<tr>
<td colspan="5">  <a href="cv.html" title="cpp/language/cv"> cv specifiers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="storage_duration.html" title="cpp/language/storage duration"> storage duration specifiers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="constexpr.html" title="cpp/language/constexpr"> constexpr specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="auto.html" title="cpp/language/auto"> auto specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="alignas.html" title="cpp/language/alignas"> alignas specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Initialization
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="default_initialization.html" title="cpp/language/default initialization"> default initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="value_initialization.html" title="cpp/language/value initialization"> value initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="zero_initialization.html" title="cpp/language/zero initialization"> zero initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="copy_initialization.html" title="cpp/language/copy initialization"> copy initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="direct_initialization.html" title="cpp/language/direct initialization"> direct initialization</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization"> aggregate initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="list_initialization.html" title="cpp/language/list initialization"> list initialization</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
<div style="display:inline-block">
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr class="t-sb-list-h2">
<td colspan="5">  Literals
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="integer_literal.html" title="cpp/language/integer literal"> integer literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="character_literal.html" title="cpp/language/character literal"> character literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="floating_literal.html" title="cpp/language/floating literal"> floating-point literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="string_literal.html" title="cpp/language/string literal"> string literals</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="bool_literal.html" title="cpp/language/bool literal"> boolean literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="nullptr.html" title="cpp/language/nullptr"> nullptr</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="user_literal.html" title="cpp/language/user literal"> user-defined</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Expressions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="value_category.html" title="cpp/language/value category"> value categories</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="eval_order.html" title="cpp/language/eval order"> order of evaluation</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="operators.html" title="cpp/language/operators"> operators</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="operator_precedence.html" title="cpp/language/operator precedence"> operator precedence</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr>
<td colspan="5">  <a href="operator_alternative.html" title="cpp/language/operator alternative"> alternative representations</a>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Utilities
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Types
</td>
</tr>

<tr>
<td colspan="5">  <a href="typedef.html" title="cpp/language/typedef"> <code>typedef</code> declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="type_alias.html" title="cpp/language/type alias"> type alias declaration</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="attributes.html" title="cpp/language/attributes"> attributes</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Casts
</td>
</tr>

<tr>
<td colspan="5">  <a href="implicit_cast.html" title="cpp/language/implicit cast"> implicit conversions</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="const_cast.html" title="cpp/language/const cast"> <code>const_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="static_cast.html" title="cpp/language/static cast"> <code>static_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="dynamic_cast.html" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"> <code>reinterpret_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="explicit_cast.html" title="cpp/language/explicit cast"> C-style and functional cast</a>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Memory allocation
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="new.html" title="cpp/language/new"> <code>new</code> expression</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="delete.html" title="cpp/language/delete"> <code>delete</code> expression</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Classes
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="class.html" title="cpp/language/class"> class declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="this.html" title="cpp/language/this"> <code>this</code> pointer</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="access.html" title="cpp/language/access"> access specifiers</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="friend.html" title="cpp/language/friend"> friend specifier</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="initializer_list.html" title="cpp/language/initializer list"> initializer lists</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Class-specific function properties
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="virtual.html" title="cpp/language/virtual"> virtual function</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="override.html" title="cpp/language/override"> override specifier</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="final.html" title="cpp/language/final"> final specifier</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="explicit.html" title="cpp/language/explicit"> explicit</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="static.html" title="cpp/language/static"> static</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Special member functions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="default_constructor.html" title="cpp/language/default constructor"> default constructor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="copy_constructor.html" title="cpp/language/copy constructor"> copy constructor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="move_constructor.html" title="cpp/language/move constructor"> move constructor</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="as_operator.html" title="cpp/language/as operator"> copy assignment</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="move_operator.html" title="cpp/language/move operator"> move assignment</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="destructor.html" title="cpp/language/destructor"> destructor</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr class="t-sb-list-h1">
<td colspan="5"> Templates
</td>
</tr>

<tr>
<td colspan="5">  <a href="class_template.html" title="cpp/language/class template"> class template </a>
</td>
</tr>

<tr>
<td colspan="5">  <strong class="selflink"> function template </strong>
</td>
</tr>

<tr>
<td colspan="5">  <a href="template_specialization.html" title="cpp/language/template specialization"> template specialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr class="t-sb-list-h1">
<td colspan="5">  Miscellaneous
</td>
</tr>

<tr>
<td colspan="5">  <a href="asm.html" title="cpp/language/asm"> Inline assembly</a>
</td>
</tr>
</table>
</div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>A function template defines a family of functions.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1 tocsection-3">
<a href="#Function_template_instantiation"><span class="tocnumber">3</span> <span class="toctext">Function template instantiation</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Explicit_instantiation"><span class="tocnumber">3.1</span> <span class="toctext">Explicit instantiation</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Implicit_instantiation"><span class="tocnumber">3.2</span> <span class="toctext">Implicit instantiation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Template_argument_deduction"><span class="tocnumber">4</span> <span class="toctext">Template argument deduction</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Template_argument_substitution"><span class="tocnumber">5</span> <span class="toctext">Template argument substitution</span></a></li>
<li class="toclevel-1 tocsection-8">
<a href="#Function_template_specialization"><span class="tocnumber">6</span> <span class="toctext">Function template specialization</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Overload_resolution"><span class="tocnumber">6.1</span> <span class="toctext">Overload resolution</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Example"><span class="tocnumber">7</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#See_Also"><span class="tocnumber">8</span> <span class="toctext">See Also</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span>
</h3>
<table class="t-sdcl-list">

<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
<tr class="t-sdcl-list-item">
<td class="t-sdcl-list-item-nopad"> <code><b>template</b></code> <code><b>&lt;</b></code> <span class="t-sparam">parameter-list</span> <code><b>&gt;</b></code> <span class="t-sparam">declaration</span>
</td>
<td class="t-sdcl-list-item-nopad">
</td>
<td class="t-sdcl-list-item-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
</table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span>
</h3>
<p><span class="t-sparam">declaration</span> defines or declares a <a href="class_template.html" title="cpp/language/class template">class (including struct and union), a member class or member enumeration type</a>, a function or member function, a static data member of a class template, or a <a href="type_alias.html" title="cpp/language/type alias">type alias</a>. It may also define a <a href="template_specialization.html" title="cpp/language/template specialization">template specialization</a>. This page focuses on function templates.
</p>
<p><span class="t-sparam">parameter-list</span> is a non-empty comma-separated list of the template parameters, each of which is either non-type parameter, a type parameter, a template parameter, or a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> of any of those. For function templates, template parameters are declared in the same manner as for class templates: see <a href="class_template.html" title="cpp/language/class template">class template</a> page for details.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Function template instantiation">edit</a>]</span> <span class="mw-headline" id="Function_template_instantiation">Function template instantiation</span>
</h3>
<p>A function template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template).
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Explicit instantiation">edit</a>]</span> <span class="mw-headline" id="Explicit_instantiation">Explicit instantiation</span>
</h4>
<table class="t-sdcl-list">

<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
<tr class="t-sdcl-list-item">
<td> <code><b>template</b></code> <span class="t-sparam">return-type</span> <code><b>&lt;</b></code> <span class="t-sparam">argument-list</span> <code><b>&gt;</b></code> <span class="t-sparam">name</span> <code><b>(</b></code> <span class="t-sparam">parameter-list</span> <code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (1)
</td>
<td class="t-sdcl-list-item-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
<tr class="t-sdcl-list-item">
<td> <code><b>template</b></code> <span class="t-sparam">return-type</span> <span class="t-sparam">name</span> <code><b>(</b></code> <span class="t-sparam">parameter-list</span> <code><b>)</b></code> <code><b>&gt; ;</b></code>
</td>
<td> (2)
</td>
<td class="t-sdcl-list-item-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
<tr class="t-sdcl-list-item">
<td> <code><b>extern</b></code> <code><b>template</b></code> <span class="t-sparam">return-type</span> <code><b>&lt;</b></code> <span class="t-sparam">argument-list</span> <code><b>&gt;</b></code> <span class="t-sparam">name</span> <code><b>(</b></code> <span class="t-sparam">parameter-list</span><code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (3)
</td>
<td> <span class="t-mark">(since C++11)</span>
</td>
</tr>



<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
<tr class="t-sdcl-list-item">
<td> <code><b>extern</b></code> <code><b>template</b></code> <span class="t-sparam">return-type</span> <span class="t-sparam">name</span> <code><b>(</b></code> <span class="t-sparam">parameter-list</span><code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (4)
</td>
<td> <span class="t-mark">(since C++11)</span>
</td>
</tr>



<tr>
<td colspan="10" class="t-sdcl-list-sep">
</td>
</tr>
</table>
<div class="t-li1">
<span class="t-li">1)</span> Explicit instantiation definition without template argument deduction</div>
<div class="t-li1">
<span class="t-li">2)</span> Explicit instantiatino definition with template argument deduction</div>
<div class="t-li1">
<span class="t-li">3)</span> Explicit instantiation declaration without template argument deduction</div>
<div class="t-li1">
<span class="t-li">4)</span> Explicit instantiation declaration with template argument deduction</div>
<p>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.
</p>
<p>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">void</span> f<span class="br0">(</span>T s<span class="br0">)</span><br>
<span class="br0">{</span><br>
    <a href="../io/basic_ostream.html"><span class="kw1427">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> s <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span><br>
<span class="br0">}</span><br>
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;double&gt;(double)</span><br>
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;char&gt;(char)</span><br>
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;int&gt;(int)</span></span>
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Implicit instantiation">edit</a>]</span> <span class="mw-headline" id="Implicit_instantiation">Implicit instantiation</span>
</h4>
<p>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be deduced from context
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="co2">#include &lt;iostream&gt;</span><br>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">void</span> f<span class="br0">(</span>T s<span class="br0">)</span><br>
<span class="br0">{</span><br>
    <a href="../io/basic_ostream.html"><span class="kw1427">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> s <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span><br>
<span class="br0">}</span><br>
<br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
    f<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;double&gt;(double)</span><br>
    f<span class="sy1">&lt;&gt;</span><span class="br0">(</span><span class="st0">'a'</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;char&gt;(char)</span><br>
    f<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;int&gt;(int)</span><br>
    <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>ptr<span class="br0">)</span><span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1036">std::<span class="me2">string</span></span></a><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// instantiates f&lt;string&gt;(string)</span><br>
<span class="br0">}</span></span>
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Template argument deduction">edit</a>]</span> <span class="mw-headline" id="Template_argument_deduction">Template argument deduction</span>
</h3>
<p>In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> To, <span class="kw1">typename</span> From<span class="sy1">&gt;</span> To convert<span class="br0">(</span>From f<span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">double</span> d<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">int</span> i <span class="sy1">=</span> convert<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span>d<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls convert&lt;int,double&gt;(double)</span>
    <span class="kw4">char</span> c <span class="sy1">=</span> convert<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span><span class="br0">(</span>d<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls convert&lt;char,double&gt;(double)</span>
    <span class="kw4">int</span><span class="br0">(</span><span class="sy2">*</span>ptr<span class="br0">)</span><span class="br0">(</span><span class="kw4">float</span><span class="br0">)</span> <span class="sy1">=</span> convert<span class="sy4">;</span> <span class="co1">// instantiates convert&lt;int, float&gt;(float)</span>
<span class="br0">}</span></pre></div></div>
<p>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1427">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Hello, world"</span> <span class="sy1">&lt;&lt;</span> <a href="../io/manip/endl.html"><span class="kw1460">std::<span class="me2">endl</span></span></a><span class="sy4">;</span>
    <span class="co1">// operator&lt;&lt; is deduced to operator&lt;&lt;&lt;char, std::char_traits&lt;char&gt;&gt; both times</span>
    <span class="co1">// std::endl is deduced to std::endl&lt;char, std::char_traits&lt;char&gt;&gt;</span>
<span class="br0">}</span></pre></div></div>
<p>For each function parameter of type <code>P</code> specified in the function template, the compiler examines the corresponding function call argument of type <code>A</code> as follows:
</p>
<ul><li> If <code>P</code> is a (possibly cv-qualified, possibly reference to) <span class="mw-geshi cpp source-cpp"><a href="../utility/initializer_list.html"><span class="kw804">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>Q<span class="sy1">&gt;</span></span> and the function call argument is a brace-enclosed list of initializers, argument deduction is attempted between the type <code>Q</code> and each element of the braced-init-list, which all must match
</li></ul>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> Q<span class="sy1">&gt;</span><br>
<span class="kw4">void</span> f<span class="br0">(</span><a href="../utility/initializer_list.html"><span class="kw804">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>Q<span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span><br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
      f<span class="br0">(</span><span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// OK: calls void f(initializer_list&lt;int&gt;)</span><br>
<span class="co1">//    f({1,"asdf"}); // error: Q can't be both int and const char*</span><br>
<span class="br0">}</span></span>
</p>
<ul><li> Otherwise, if the function call argument is a braced-init-list, the type cannot be deduced and must be specified
</li></ul>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span><br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
<span class="co1">//    f({1,2,3}); // error: T cannot be deduced from a braced-init-list</span><br>
      f<span class="sy1">&lt;</span><a href="../container/vector.html"><span class="kw1057">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;</span><span class="br0">(</span><span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, T is specified</span><br>
<span class="br0">}</span></span>
</p>
<ul><li> If the function template ends with a parameter pack, each remaining argument is compared with the type of the parameter pack and each comparison deduces the next type in the expansion.
</li></ul>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> H, <span class="kw1">class</span> ...<span class="me1">Tail</span><span class="sy1">&gt;</span><br>
<span class="kw4">void</span> f<span class="br0">(</span>H, Tail...<span class="br0">)</span><span class="sy4">;</span><br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
    <span class="kw4">int</span> x<span class="sy4">;</span> <span class="kw4">double</span> y<span class="sy4">;</span> <span class="kw4">char</span> z<span class="sy4">;</span><br>
    f<span class="br0">(</span>x, y, z<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// H = int, Tail = {double, char}</span><br>
<span class="br0">}</span></span>
</p>
<ul>
<li> If a function template has a parameter pack that is not at the end, the pack is not deducible and must be specified, along with all the types that follow.
</li>
<li> If <code>P</code> is a non-reference type,
</li>
</ul>
<dl><dd>
<ul>
<li> If <code>A</code> is an array type, the pointer to an element of <code>A</code> is used in place of <code>A</code> for deduction.
</li>
<li> If <code>A</code> is a function type, the pointer to this function type is used in place of <code>A</code> for deduction.
</li>
<li> Otherwise, if <code>A</code> is a cv-qualified type, then the top level cv-qualifiers are ignored for deduction
</li>
</ul>
</dd></dl>
<ul>
<li> If <code>P</code> is a cv-qualified type, the top-level cv qualifiers are ignored for deduction.
</li>
<li> If <code>P</code> is a reference type, the type referred to by <code>P</code> is used for deduction.
</li>
<li> If <code>P</code> is an rvalue reference to a template parameter, and the corresponding function call argument is an lvalue, the type lvalue reference to <code>A</code> is used in place of <code>A</code> for deduction (Note: this is the basis for the action of <span class="mw-geshi cpp source-cpp"><a href="../utility/forward.html"><span class="kw911">std::<span class="me2">forward</span></span></a></span>)
</li>
</ul>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">int</span> f<span class="br0">(</span>T<span class="sy3">&amp;&amp;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// P is rvalue reference to cv-unqualified T (special case)</span><br>
<br>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">int</span> g<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;&amp;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// P is rvalue reference to cv-qualified T (not special)</span><br>
<br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
    <span class="kw4">int</span> i<span class="sy4">;</span><br>
    <span class="kw4">int</span> n1 <span class="sy1">=</span> f<span class="br0">(</span>i<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// argument is lvalue:     calls f&lt;int&amp;&gt;(int&amp;) (special case)</span><br>
    <span class="kw4">int</span> n2 <span class="sy1">=</span> f<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// argument is not lvalue: calls f&lt;int&gt;(int&amp;&amp;)</span><br>
<br>
<span class="co1">//    int n3 = g(i); // error: deduces to g&lt;int&gt;(const int&amp;&amp;), which</span><br>
<span class="co1">//    // cant bind an rvalue reference to an lvalue:</span><br>
<span class="br0">}</span></span>
</p>
<ul>
<li> After these transformations, the deduction process attempts to find such template arguments that would make <code>P</code> and <code>A</code> identical, except that <table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: the three exceptions and the implicit conversions </td>
</tr></table>
</li>
<li> If <code>P</code> is a function type, pointer to function, or pointer to member function,
</li>
</ul>
<dl><dd>
<ul>
<li> If the argument is a set of overloaded functions that includes at least one function template, the parameter cannot be deduced.
</li>
<li> If the argument is a set of overloaded functions not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If more than one succeeds, the template parameter cannot be deduced.
</li>
</ul>
</dd></dl>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span><br>
<span class="kw4">int</span> f<span class="br0">(</span>T <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span>T<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span><br>
<br>
<span class="kw4">int</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span><br>
<span class="kw4">int</span> g<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// two overloads</span><br>
<br>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br>
<span class="br0">{</span><br>
 <span class="kw4">int</span> i <span class="sy1">=</span> f<span class="br0">(</span>g<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// only one overload works: calls f(int (*)(int))</span><br>
<span class="br0">}</span></span>
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: The huge amount of stuff from 14.8.2.5. Except it will have to be made easy-to-follow somehow </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Template argument substitution">edit</a>]</span> <span class="mw-headline" id="Template_argument_substitution">Template argument substitution</span>
</h3>
<p>When a template argument is specified explicitly, but does not match the type of the corresponding function argument exactly, the template argument is adjusted by the following rules:
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Function template specialization">edit</a>]</span> <span class="mw-headline" id="Function_template_specialization">Function template specialization</span>
</h3>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: note that there is a page for specializations in general, only function specifics go here: lack of partials, interaction with function overloads </td>
</tr></table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Overload resolution">edit</a>]</span> <span class="mw-headline" id="Overload_resolution">Overload resolution</span>
</h4>
<p>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>              <span class="co1">// template overload</span><br>
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>             <span class="co1">// template overload</span><br>
<span class="kw4">void</span>                     f<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>         <span class="co1">// nontemplate overload</span><br>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>          <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>            <span class="co1">// specialization of #1</span><br>
<br>
f<span class="br0">(</span><span class="st0">'a'</span><span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// calls #1</span><br>
f<span class="br0">(</span>new <span class="kw4">int</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls #2</span><br>
f<span class="br0">(</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// calls #3</span><br>
f<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>          <span class="co1">// calls #4</span></span>
</p>
<p>Note that only non-template and primary template overloads participate in overload resolution. The specializations are not overloads and are not considered. Only after the overload resolution selects the best-matching primary function template, its specializations are examined to see if one is a better match.
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// overload #1 for all types</span><br>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>          <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// specialization of #1 for pointers to int</span><br>
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// overload #2 for all pointer types</span><br>
<br>
f<span class="br0">(</span>new <span class="kw4">int</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls #2, even though #1 would be a perfect match</span></span>
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: actual rules from the std </td>
</tr></table>
<h2>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span>
</h2>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: no example </td>
</tr></table>
<h2>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: See Also">edit</a>]</span> <span class="mw-headline" id="See_Also">See Also</span>
</h2>
<ul>
<li> <a href="class_template.html" title="cpp/language/class template">class template</a>
</li>
<li> <a href="function.html" title="cpp/language/function">function declaration</a>
</li>
</ul>

<!-- 
NewPP limit report
Preprocessor node count: 3242/1000000
Post-expand include size: 92749/2097152 bytes
Template argument size: 15110/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:5067-0!*!0!!en!*!* and timestamp 20130414142102 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;oldid=46743</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special:Categories" title="Special:Categories">Categories</a>: <ul>
<li><a href="http://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li>
<li><a href="http://en.cppreference.com/w/Category:Todo_without_reason" title="Category:Todo without reason">Todo without reason</a></li>
<li><a href="http://en.cppreference.com/w/Category:Todo_no_example" title="Category:Todo no example">Todo no example</a></li>
</ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script src="../../../common/loadac2a.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script src="../../../common/load345b.php"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0
	,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:4:3740695a1552aee37d594967bd36f869 */
}
</script>
<!-- Served in 2.728 secs. -->        
	</body>
<!-- Cached 20130414142102 -->



</html>
