<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">



<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Dependent names - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/load202e.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}#toc{display:none}.editsection{display:none}

/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:4:b677bc2b5ec37947892a2d0853532528 */</style>
<script src="../../../common/load404e.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "cpp/language/dependent_name", "wgTitle": "cpp/language/dependent name", "wgCurRevisionId": 47173, "wgArticleId": 9611, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Todo with reason"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_dependent_name action-view skin-cppreference2 cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Dependent names</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a> | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="line-height:1.1em;">

<tr>
<td colspan="5">  <a href="../language.html" title="cpp/language"> Language</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../header.html" title="cpp/header"> Standard library headers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../concept.html" title="cpp/concept"> Concepts</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../utility.html" title="cpp/utility"> Utilities library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../string.html" title="cpp/string"> Strings library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../container.html" title="cpp/container"> Containers library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../iterator.html" title="cpp/iterator"> Iterators library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../numeric.html" title="cpp/numeric"> Numerics library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../io.html" title="cpp/io"> Input/output library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../locale.html" title="cpp/locale"> Localizations library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../language.html" title="cpp/language"> C++ language</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr class="t-sb-list-h1">
<td colspan="5">  General topics
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="../preprocessor.html" title="cpp/preprocessor"> Preprocessor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../comment.html" title="cpp/comments" class="mw-redirect"> Comments</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../keyword.html" title="cpp/keyword"> Keywords</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="ascii.html" title="cpp/language/ascii"> ASCII chart</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="escape.html" title="cpp/language/escape"> Escape sequences</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="history.html" title="cpp/language/history"> History of C++</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Flow control
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Conditional execution statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="if.html" title="cpp/language/if"> <code>if</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="switch.html" title="cpp/language/switch"> <code>switch</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Iteration statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="for.html" title="cpp/language/for"> <code>for</code> loop</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="range-for.html" title="cpp/language/range-for"> range-<code>for</code> loop</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="while.html" title="cpp/language/while"> <code>while</code> loop</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="do.html" title="cpp/language/do"> <code>do-while</code> loop</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Jump statements
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="continue.html" title="cpp/language/continue"> <code>continue</code> statement</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="break.html" title="cpp/language/break"> <code>break</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="goto.html" title="cpp/language/goto"> <code>goto</code> statement</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="return.html" title="cpp/language/return"> <code>return</code> statement</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Functions
</td>
</tr>

<tr>
<td colspan="5">  <a href="function.html" title="cpp/language/function"> function declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="lambda.html" title="cpp/language/lambda"> lambda function declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="function_template.html" title="cpp/language/function template"> function template </a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="inline.html" title="cpp/language/inline"> inline specifier</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="except_spec.html" title="cpp/language/except spec"> exception specifications</a> <span class="t-mark">(deprecated)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="noexcept_spec.html" title="cpp/language/noexcept spec"> noexcept specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Exceptions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="throw.html" title="cpp/language/throw"> throw expression</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="try_catch.html" title="cpp/language/try catch"> try-catch block</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Namespaces
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="namespace.html" title="cpp/language/namespace"> namespace declaration</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="namespace_alias.html" title="cpp/language/namespace alias"> namespace aliases</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Types
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="types.html" title="cpp/language/types"> fundamental types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="class.html" title="cpp/language/class"> compound types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="enum.html" title="cpp/language/enum"> enumeration types</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="union.html" title="cpp/language/union"> union types</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="function.html" title="cpp/language/function"> function types</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr>
<td colspan="5">  <a href="decltype.html" title="cpp/language/decltype"> <code>decltype</code> specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Specifiers
</td>
</tr>

<tr>
<td colspan="5">  <a href="cv.html" title="cpp/language/cv"> cv specifiers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="storage_duration.html" title="cpp/language/storage duration"> storage duration specifiers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="constexpr.html" title="cpp/language/constexpr"> constexpr specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="auto.html" title="cpp/language/auto"> auto specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="alignas.html" title="cpp/language/alignas"> alignas specifier</a> <span class="t-mark">(C++11)</span>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Initialization
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="default_initialization.html" title="cpp/language/default initialization"> default initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="value_initialization.html" title="cpp/language/value initialization"> value initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="zero_initialization.html" title="cpp/language/zero initialization"> zero initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="copy_initialization.html" title="cpp/language/copy initialization"> copy initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="direct_initialization.html" title="cpp/language/direct initialization"> direct initialization</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization"> aggregate initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="list_initialization.html" title="cpp/language/list initialization"> list initialization</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
<div style="display:inline-block">
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr class="t-sb-list-h2">
<td colspan="5">  Literals
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="integer_literal.html" title="cpp/language/integer literal"> integer literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="character_literal.html" title="cpp/language/character literal"> character literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="floating_literal.html" title="cpp/language/floating literal"> floating-point literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="string_literal.html" title="cpp/language/string literal"> string literals</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="bool_literal.html" title="cpp/language/bool literal"> boolean literals</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="nullptr.html" title="cpp/language/nullptr"> nullptr</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="user_literal.html" title="cpp/language/user literal"> user-defined</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Expressions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="value_category.html" title="cpp/language/value category"> value categories</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="eval_order.html" title="cpp/language/eval order"> order of evaluation</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="operators.html" title="cpp/language/operators"> operators</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="operator_precedence.html" title="cpp/language/operator precedence"> operator precedence</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr>
<td colspan="5">  <a href="operator_alternative.html" title="cpp/language/operator alternative"> alternative representations</a>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Utilities
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Types
</td>
</tr>

<tr>
<td colspan="5">  <a href="typedef.html" title="cpp/language/typedef"> <code>typedef</code> declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="type_alias.html" title="cpp/language/type alias"> type alias declaration</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="attributes.html" title="cpp/language/attributes"> attributes</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr class="t-sb-list-h2">
<td colspan="5">  Casts
</td>
</tr>

<tr>
<td colspan="5">  <a href="implicit_cast.html" title="cpp/language/implicit cast"> implicit conversions</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="const_cast.html" title="cpp/language/const cast"> <code>const_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="static_cast.html" title="cpp/language/static cast"> <code>static_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="dynamic_cast.html" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"> <code>reinterpret_cast</code> conversion</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="explicit_cast.html" title="cpp/language/explicit cast"> C-style and functional cast</a>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Memory allocation
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="new.html" title="cpp/language/new"> <code>new</code> expression</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="delete.html" title="cpp/language/delete"> <code>delete</code> expression</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Classes
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="class.html" title="cpp/language/class"> class declaration</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="this.html" title="cpp/language/this"> <code>this</code> pointer</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="access.html" title="cpp/language/access"> access specifiers</a>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="friend.html" title="cpp/language/friend"> friend specifier</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="initializer_list.html" title="cpp/language/initializer list"> initializer lists</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Class-specific function properties
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="virtual.html" title="cpp/language/virtual"> virtual function</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="override.html" title="cpp/language/override"> override specifier</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="final.html" title="cpp/language/final"> final specifier</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="explicit.html" title="cpp/language/explicit"> explicit</a>  <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="static.html" title="cpp/language/static"> static</a>
</td>
</tr>
</table>
</div>
</td>
</tr>


<tr class="t-sb-list-h2">
<td colspan="5">  Special member functions
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="default_constructor.html" title="cpp/language/default constructor"> default constructor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="copy_constructor.html" title="cpp/language/copy constructor"> copy constructor</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="move_constructor.html" title="cpp/language/move constructor"> move constructor</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
</td>
<td>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr>
<td colspan="5">  <a href="as_operator.html" title="cpp/language/as operator"> copy assignment</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="move_operator.html" title="cpp/language/move operator"> move assignment</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="destructor.html" title="cpp/language/destructor"> destructor</a>
</td>
</tr>
</table>
</div>
</td>
</tr>

<tr class="t-sb-list-h1">
<td colspan="5"> Templates
</td>
</tr>

<tr>
<td colspan="5">  <a href="class_template.html" title="cpp/language/class template"> class template </a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="function_template.html" title="cpp/language/function template"> function template </a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="template_specialization.html" title="cpp/language/template specialization"> template specialization</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr class="t-sb-list-h1">
<td colspan="5">  Miscellaneous
</td>
</tr>

<tr>
<td colspan="5">  <a href="asm.html" title="cpp/language/asm"> Inline assembly</a>
</td>
</tr>
</table>
</div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>Inside the definition of a template (both <a href="class_template.html" title="cpp/language/class template">class template</a> and <a href="function_template.html" title="cpp/language/function template">function template</a>), the contents of some types and the values and the types of some expressions are not known until the template is instantiated, because they depend on the template parameter.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Dependent_types"><span class="tocnumber">1</span> <span class="toctext">Dependent types</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Type-dependent_expressions"><span class="tocnumber">2</span> <span class="toctext">Type-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Value-dependent_expressions"><span class="tocnumber">3</span> <span class="toctext">Value-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Binding_rules"><span class="tocnumber">4</span> <span class="toctext">Binding rules</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Current_instantiation"><span class="tocnumber">5</span> <span class="toctext">Current instantiation</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Unknown_specializations"><span class="tocnumber">6</span> <span class="toctext">Unknown specializations</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#The_typename_disambiguator_for_dependent_names"><span class="tocnumber">7</span> <span class="toctext">The typename disambiguator for dependent names</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#The_template_disambiguator_for_dependent_names"><span class="tocnumber">8</span> <span class="toctext">The template disambiguator for dependent names</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Dependent types">edit</a>]</span> <span class="mw-headline" id="Dependent_types">Dependent types</span>
</h3>
<p>The following types are dependent types:
</p>
<ul>
<li> template parameter
</li>
<li> a member of an <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> a nested class or enum that is a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> a cv-qualified version of a dependent type
</li>
<li> a compound type constructed from a dependent type
</li>
<li> an array type constructed from a dependent type, or whose size is a value-dependent expression
</li>
<li> template instantiation whose name is a template parameter, or any of template arguments is a dependent type/expression
</li>
<li> the result of decltype() applied to a type-dependent expression
</li>
</ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: examples for each bullet </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Type-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Type-dependent_expressions">Type-dependent expressions</span>
</h3>
<p>The following expressions are type-dependent
</p>
<ul>
<li> an expression whose any subexpression is a type-dependent expression
</li>
<li> an expression that contains an identifier whose type is a dependent type
</li>
<li> an expression that contains a dependent template instantiation
</li>
<li> an expression that contains a conversion function call to a dependent type
</li>
<li> an expression that contains a nested name that refers to a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> any cast expression to a dependent type
</li>
<li> new-expression that creates an object of a dependent type
</li>
<li> an expression that names a static data member of type array of unknown bound
</li>
<li> <span class="mw-geshi cpp source-cpp">this</span>, if the class type is a dependent type
</li>
<li> member access expression that refers to a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> member access expression that refers to a member of the <a href="dependent_name.html#Current_instantiation" title="cpp/language/dependent name">current instantiation</a>, whose type is a dependent type
</li>
</ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: examples for each bullet </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Value-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Value-dependent_expressions">Value-dependent expressions</span>
</h3>
<ul>
<li> an expression whose any subexpression is a value-dependent expression
</li>
<li> an expression that contains the name of a non-type template parameter
</li>
<li> an expression that contains a name declared with a dependent type
</li>
<li> a constant initialized from a value-dependent expression
</li>
<li> <span class="mw-geshi cpp source-cpp">sizeof</span>, <span class="mw-geshi cpp source-cpp">alignof</span>, or <span class="mw-geshi cpp source-cpp"><span class="kw1">typeid</span></span> of a type-dependent expression or of a dependent type
</li>
<li> <span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> of a type-dependent expression
</li>
<li> any cast expression to a dependent type or from a value-dependent expression
</li>
<li> an expression that names a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
</ul>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Binding rules">edit</a>]</span> <span class="mw-headline" id="Binding_rules">Binding rules</span>
</h3>
<p>Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match: 
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3mfe-yXSNsRHZd78uaBuE0N6ai0JE14O0VJ8HF3GAeNfyLHzJzC_TxoYfXgeHxXkaUEjkd6YDTYfu46lzBzIZtc3rnSRCpadoui8f6Ym1F9Ew0JzK37nrn76nS9sUJfuBC9PIKuc4RB_aaEs67C8S_hYkgCw6agTvkZ4C53llimA1iD1x4wBD1RC3jR_K4mtxqJclY5bsFTjVYiyHL3RSrpMOvfu__ecuFcoYh9HLZbd8Z8yeu9QX069nCXs2FrSzsC013ouWA==" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1428">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(double)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span>
        g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-dependent expression, bound now</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1428">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(int)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(int)</span>
 
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(double)</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Dependent names are looked up in both the declaration <i>and</i> the instantiation context.  <i>However</i>, for <i>unqualified</i> function names in the instantiation context, <i>only</i> argument-dependent lookup is used:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3mfBAcUTJ9gXZ0H2QFu2Y6MnWbHLeRjbhVrSNiNclri6zTf8mKxP4M3zaPefIWHOhvId3CI2FGqgsFVuJIlC-x8SQnXsNueP-eIKl9Uvw02M4stEhqswP6fDd4qxRS8joQ_H4RcxpxJE0GZYVQ0qHnnfWmiN1Aw_uG76pq2jcG8060wx5Y0OzTbVGSYKYLSQkk4rqMtbdnaTXyREvO982U4wJ6gt1ctDXVE40FlXESaXTulk1RWoNBM4aYLjzGPfYYVIFkYp7AseavjgBxLC_9nsAJC-s7g-NZnNKIuQ-ShEevkUaYbEZmYGQBo=" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">namespace</span> M <span class="br0">{</span>
  <span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span>
    g<span class="br0">(</span>t<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> g<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw1">namespace</span> N <span class="br0">{</span>
  <span class="kw1">struct</span> Z <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
  <span class="kw4">void</span> g<span class="br0">(</span>Z<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> g<span class="br0">(</span>Z<span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
  <span class="kw4">int</span> i<span class="sy4">;</span>
  <span class="kw4">char</span> c<span class="sy4">;</span>
  <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a> s<span class="sy4">;</span>  
  Z z<span class="sy4">;</span>
 
  f<span class="br0">(</span>i<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds M::g(int)</span>
  f<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds M::g(int), not ::g(char)</span>
  f<span class="br0">(</span>s<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: no declaration visible to f</span>
  f<span class="br0">(</span>z<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds N::g(Z) in associated namespace of Z, not ::g(Z)</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>[<i>Note:</i> 
The purpose of this is rule is to help guard against violations of the one-definition-rule (ODR) for template instantiations.  For instance:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3qcAi-TTNth-aTdV6Hxxox-_mPNaOBBv0CYeAhG2HgDm7LnA18GydAx_izvXR-fYqn5gvQeiN4y52PVHrTudUbbAGro6G_3ZyeR1S2PSm4T5OwCTAgj7vk5r4eOjajKn5vMPVHqPGQ7QKe7nN81iYrVzpWHILq7_i__fePrXkCsFpuzI6XWXyhfhOuSU950JNUIjdiqnM9NtiO2l_RA8N7oNozVcgSYUn7dGOq0l5vlVX_-8-CoWqt1xez1VpLMcXXOSslr9OUtdrASN7iaq5i34fLJ2YLVUr_0CzODw-Xj5Ohtpt_sr805TzFZ81Orc3nywfwIDW_eA58dJ3IFLKNW471wP7rBfuxetnOemAycSgbefWGdVYE6aYfnvop9oF7EjXEveL6DUR_T3j1jMW0Qr" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
 
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> writeObject<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1428">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Value = "</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <a href="../io/manip/endl.html"><span class="kw1461">std::<span class="me2">endl</span></span></a><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 1:</span>
 
<span class="co1">// Programmer 1 wants to allow E::writeObject </span>
<span class="co1">// to work with vector&lt; int &gt;</span>
 
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1403">std::<span class="me2">ostream</span></span></a> <span class="sy3">&amp;</span>operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="co1">// ...</span>
    writeObject<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P1::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 2:</span>
 
<span class="co1">// Programmer 2 wants to allow someExternalLibrary::writeObject </span>
<span class="co1">// to work with vector&lt; int &gt;</span>
 
<span class="kw1">namespace</span> P2 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1403">std::<span class="me2">ostream</span></span></a> <span class="sy3">&amp;</span>operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw4">void</span> doSomethingElse<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="co1">// ...</span>
    writeObject<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P2::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>In the above example, were it not for the argument-dependent name lookup rule, the instantiation of <span class="mw-geshi cpp source-cpp">E<span class="sy4">::</span><span class="me2">writeObject</span><span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> <span class="sy1">&gt;</span></span> would have two different definitions: one using <span class="mw-geshi cpp source-cpp">P1<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span> and one using <span class="mw-geshi cpp source-cpp">P2<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span>.  On many implementations this may very well not be detected, leading to one or the other being used in both instances.
</p>
<p>The <span class="mw-geshi cpp source-cpp"><a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span></span> class does not have a standard output operator.  There is no context-independent interpretation for <span class="mw-geshi cpp source-cpp"><a href="../io/basic_ostream.html"><span class="kw1403">std::<span class="me2">ostream</span></span></a> <span class="sy1">&lt;&lt;</span> <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a></span>, and this is by intent.  Otherwise, the designers of <span class="mw-geshi cpp source-cpp"><a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a></span> would have provided one in the <span class="mw-geshi cpp source-cpp">std</span> namespace.  Since they didn't, users <b>should not</b> attempt to provide one by declaring it in <span class="mw-geshi cpp source-cpp">std</span> - doing so will lead to multiple violations of the ODR.  A "correct" solution would involve creating or deriving one's own type:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3mcAi8TSNth-6TRVaHQgSm4RxGNCbqyrodi1fGY4WFJu2XxOecUWCibrBs1afs2pptbQC1zRtKslkg40JfFsWTSSUZEFPmg6jgOU_rqISx9e2QXNK2CVWG4aZizNqS8p9RC6aa3WEHr9joHhscjUIFIRjhXMAMAfzvBj6NfrYvLt-lsCs7oiGzLf-htL48JbG0gXXmcJJes5UkRJg1D3roJSRP9z6dy5nRDuuuGOLKkFhXKcmrXUj6TJJMCKhaCIV3Pdrj9luo-YnZ67-uwC7RYIUvy1TjzlZuACywygzFap2P0CVErD4kZjNIuUJHgHrmbMfB5r_F0BEH3hUfkRgyJ6HnOx7YKKPvOUDP2TPHHh1FdCDeiRsOOOV-o9jJ_xke6CPFuK1iqTW_h7U4cr" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
 
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> writeObject<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1428">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Value = "</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <a href="../io/manip/endl.html"><span class="kw1461">std::<span class="me2">endl</span></span></a><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 1:</span>
 
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <span class="co1">// ok, separate type</span>
  <span class="kw1">class</span> vector<span class="sy4">:</span> <span class="kw1">public</span> <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a> <span class="br0">{</span>
    <span class="kw1">using</span> std<span class="sy4">::</span><span class="me2">vector</span><span class="sy4">::</span><span class="me2">vector</span><span class="sy4">;</span>
  <span class="br0">}</span><span class="sy4">;</span>
  <span class="co1">// now this means operator&lt;&lt;(P1::vector&lt; int &gt;)</span>
  <a href="../io/basic_ostream.html"><span class="kw1403">std::<span class="me2">ostream</span></span></a> <span class="sy3">&amp;</span>operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    vector<span class="sy1">&lt;</span> <span class="kw4">int</span> <span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="co1">// ...</span>
    writeObject<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates writeObject(P1::vector&lt; int &gt;)</span>
                    <span class="co1">//     using above operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>-- <i>end note</i> ]
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: there's more to say about dependent name lookup at the point of instantiation </td>
</tr></table>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: explain argument-dependent lookup </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Current instantiation">edit</a>]</span> <span class="mw-headline" id="Current_instantiation"> Current instantiation </span>
</h3>
<p>Within the definition of a template class or nested class of a template class (or member function thereof), some names will be immediately bound to members of that class.
</p>
<p>In such a context, the term <i>current instantiation</i> simply refers to the instantiation of that class template with its given parameters as arguments (i.e. the class or member that is actually being defined):
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3q8C96GTNti9aVW9mTOU5oeB5G5pG5Nv9wG8XV2wiQqQGefSQP6rVzB7mPzgrZRGfsJk20ZONJOiNj5M9l3PZmxqlbkFzC-jTRdxZ10eOl96yyrDOMr6ti6dxe-w87m33i_pQ_-MVaDVnRK5N-B7-UV3_w8O4Ln7XusCVA8psOG_FEc6MH8x0SGcMsGkmsWMlOpIeghfoUjyH6IkSDyj4xcRNY0W4HkxKSiGhc2QzIjtTcpc8SgpMfVJKj3gnideknapTpaisIfIKw4rwk1_Fqp2FMFiPI-LYNh4ncAPZt6WO500VCp0pFG0kxnPDQ==" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C <span class="br0">{</span>
 
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is not the current instantiation</span>
  C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span> <span class="sy2">*</span>p4<span class="sy4">;</span>      <span class="co1">// C&lt; T2, T1 &gt; is not the current instantiation</span>
 
  <span class="kw1">struct</span> D <span class="br0">{</span>
    D <span class="sy2">*</span>q0<span class="sy4">;</span>                  <span class="co1">// D is the current instantiation</span>
    C<span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q1<span class="sy4">;</span>               <span class="co1">// C::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q2<span class="sy4">;</span>     <span class="co1">// C&lt; T1, T2 &gt;::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q3<span class="sy4">;</span> <span class="co1">// C&lt; T1 *, T2 * &gt;::D is not the current instantiation</span>
    C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q4<span class="sy4">;</span>     <span class="co1">// C&lt; T2, T1 &gt;::D is not the current instantiation</span>
  <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="br0">{</span>
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is not the current instantiation</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Specifically, the current instantiation is referenced within a class template by one of:
</p>
<ul>
<li> the template name [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">C</span> in both templates above]
</li>
<li> the template name with its formal parameters as arguments [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span></span> within the primary template above, <span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span></span> within the partial specialization above]
</li>
</ul>
<p>Or, within a nested class of a class template:
</p>
<ul><li> the nested class name referenced as a member of the current instantiation [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">D</span>, <span class="mw-geshi cpp source-cpp">C<span class="sy4">::</span><span class="me2">D</span></span>, <span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span></span> above].
</li></ul>
<p>A name used within a template class or class member, though dependent, may be understood to reference a member of the current instantiation:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3pcFd8WSRty9STnLkCBpA7ij2WEnLsOcKMQG9UNnYS8pOvSOsICapylnujhMhhqRTwCha8onqXBvbRkvK92Ui_kS7-u8wxXGSnjIN0YU4wKU4TfJ7W4IloirSb3r-L3ZoDAFjGJ4nkNQrwnEWlQxDCnabkkGVjDTzSEi-Brrp0gSHXiYAWC3OPFP6anC2MBM2KthlyQeA0HlEtEAHzl5tuMEfVI9QxHv-S5H-1FLGs9Tfilfr_4wKlKGbct2YBw-Y5u4N75pjqp0Uhef2aeIHb15ZH6Xub7a52nEzt9vyOxlJ-nQXwGZPOFQVCjrJ0NQSCpLd8SVPxSK8z1lt2DS2yYgd9beSslQ5G6hvdMXtpDcj5aQImxd5NtkBaIH2UysVLrxGB9BMQtzWeDR5TwPgPGaVUD1pbr2AakCf15KfFw-AmrvlNs355cwb4bmnqoVW_XZ006C3vBiN5BBJM8S4vNMm6mdLOucdtU=" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Z <span class="br0">{</span> <span class="kw4">int</span> z<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> Y <span class="br0">{</span> <span class="kw4">int</span> y<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> A<span class="sy4">:</span> <span class="kw1">public</span> B<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span>, <span class="kw1">public</span> Z <span class="br0">{</span>
  <span class="kw4">int</span> i<span class="sy4">;</span>
  <span class="kw4">int</span> getI<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> i<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI2<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI3<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getJ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// could perhaps be B&lt; T &gt;::j</span>
  <span class="kw4">int</span> getK<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span><span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// could perhaps be B&lt; T &gt;::k</span>
                                            <span class="co1">//  or a member k of a </span>
                                            <span class="co1">//  partial or explicit </span>
                                            <span class="co1">//  specializaton of A</span>
  <span class="kw4">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> z<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to Z::z</span>
  <span class="kw4">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// refers to Y&lt; T &gt;::y	      </span>
 
  <span class="kw4">static</span> <span class="kw4">int</span> getI<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>i<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to A::i in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getJ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>j<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// could perhaps be B&lt; T &gt;::j in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getK<span class="br0">(</span>A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span> <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>k<span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// could perhaps be B&lt; T &gt;::k in (*a)</span>
                                                <span class="co1">//  or a member k of a partial or </span>
                                                <span class="co1">//  explicit specializaton of A in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getZ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>z<span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// refers to Z::z in (*a)	</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>A name is a <i>member of the current instantiation</i> if it is either:
</p>
<ul>
<li> an unqualified class member name [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">i</span> above]
</li>
<li> an unqualified member name of a non-<a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base class [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">z</span> above]
</li>
<li> a qualified class member name, where the class name is the current instantiation [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">A<span class="sy4">::</span><span class="me2">i</span></span> or <span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span></span> above]
</li>
<li> an object member reference, where the object type is the current instantiation [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>i</span> above]
</li>
</ul>
<p>Note that it is implicit in these requirements that name lookup finds a declaration of the name within the scope of the class.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Unknown specializations">edit</a>]</span> <span class="mw-headline" id="Unknown_specializations"> Unknown specializations </span>
</h3>
<p>Within a template class or function definition, lookup of a qualified name or obejct member reference may be delayed until instantiation if it is deemed to be a member of an <i>unknown specialization</i> (i.e. belonging to a template specialization whose definition is not yet known).  Such a specialization could be:
</p>
<ul>
<li> a <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base class
</li>
<li> a partial or explicit specialization of the given template
</li>
<li> a specialization of an entirely different template
</li>
</ul>
<p>Referring to the second example in the section on <a href="dependent_name.html#Current_instantiation" title="cpp/language/dependent name">Current instantiation</a>, within a class scope, a qualified name or object member reference is a <i>member of an unknown specialization</i> if the qualifying class or object type (call it <i>QT</i>) is <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> and either:
</p>
<ul>
<li> <i>QT</i> is not the current instantiation [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span></span>, <span class="mw-geshi cpp source-cpp">Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span></span>, <span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>k</span> above]
</li>
<li> <i>QT</i> is the current instantiation, <i>but</i> does not contain a declaration of the name <i>and</i> has at least one <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base [<i>Ex:</i> <span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span></span>, <span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>j</span> above]
</li>
</ul>
<p>The latter case implies that when the qualified name or object type is the current instantiation, then either the name must be declared within the class or the class must have a <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base.
</p>
<p>[<i>Note:</i> Within a non-member function template, all such names with <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> qualifying/object types are considered to be members of unknown specializations, since obviously there are no members to speak of in such a scope.]
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The typename disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_typename_disambiguator_for_dependent_names">The <span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span> disambiguator for dependent names</span>
</h3>
<p>In a template definition, a name that is dependent on a template parameter is not considered to be a type unless the keyword <span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span> is used:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3o_Ad8XSNsRFeeKjFRNGuHaOmIyiCHKd21QipoDd3DD5VfHXF-ot3121xGTubeYo8dkE7mx6nPh_1gcU0VptGXpQEYp3MT3-yPFxO3TO8-6_0-a_jsYWiD_kS6_w2iwKjb9GqB3aqVJbVUwE7iuNoBbCWTdsZgZ7cx21czj-ztWxldsZBszq2tcU2W1E0JHgMaer89YiH9yO_AdKheo8D01B5Y5-jEkbIN-NXyE8JXnqs8vLUbV7ffiX4vYNZhrAZLU1oY-UnOoS6hwn3mJ9vWPbH_5MckwhZi0VkjVx6S1u4CGL0OnR6zwtfRcjtd4v7YeCitVHMGxBEMzKAMF79QHAALhC1dzXSmgOsWvc6tDB01aWOpCNBf7eIxINCG-WnnwRdTrVlfFAFXOEC0rVeH9ddPMZSBA_egqjbdR8PUEI" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> p <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> foo <span class="br0">(</span><span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span>
<span class="br0">{</span>
 
    <span class="co1">// std::vector&lt;T&gt;::const_iterator is a dependent name,</span>
    <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> it <span class="sy1">=</span> v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// without 'typename', the following is parsed as multiplication </span>
    <span class="co1">// of the type-dependent member variable 'const_iterator' </span>
    <span class="co1">// and some variable 'p'. Since there is a global 'p' visible</span>
    <span class="co1">// at this point, this template definition compiles.</span>
    <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy2">*</span> p<span class="sy4">;</span> 
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    foo<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// template instantiation fails: there is no member variable</span>
            <span class="co1">// called 'const_iterator' in the type std::vector&lt;int&gt;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span> may only be used in this way before qualified names, e.g. T::x.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The template disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_template_disambiguator_for_dependent_names">The <span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span> disambiguator for dependent names</span>
</h3>
<p>Similarly, in a template definition, a dependent name is not considered to be a template name unless the disambiguation keyword <span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span> is used:
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3m8ci6WSRti-ZfIaYKtiYgqJngUsz1YDljhpQxvfB_uP_7NkRb3E-27h2fjjNas7u2Y6yyIogPnwuITdJupiZYcttfaRjF7NJDjT_nccC5vn5OVoT33UamuV6-X0yvMe50FWzta0UBY4Ah99xmpGf5vWgn49yyvvV0Z7z5sWiE1xsf_TPzz7Wjmt-xfqlEQ=" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">foo</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: &lt; parsed as less than operator</span>
    s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span> may only be used in this way after operators <span class="mw-geshi cpp source-cpp"><span class="sy4">::</span></span> (scope resolution), <span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span> (member access through pointer), and <span class="mw-geshi cpp source-cpp">.</span> (member access), the following are all valid examples:
</p>
<ul>
<li> <span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
</li>
<li> <span class="mw-geshi cpp source-cpp">s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
</li>
<li> <span class="mw-geshi cpp source-cpp">this<span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
</li>
<li> <span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span> t<span class="sy4">::</span><span class="kw1">template</span> iterator<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span> v<span class="sy4">;</span></span>
</li>
</ul>

<!-- 
NewPP limit report
Preprocessor node count: 3042/1000000
Post-expand include size: 88971/2097152 bytes
Template argument size: 34661/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9611-0!*!0!!en!*!* and timestamp 20130426233832 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&amp;oldid=47173</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script src="../../../common/loadac2a.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script src="../../../common/load345b.php"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0
	,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:4:3740695a1552aee37d594967bd36f869 */
}
</script>
<!-- Served in 0.053 secs. -->        
	</body>
<!-- Cached 20130426235414 -->



</html>
