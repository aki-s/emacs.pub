<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">



<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>std::memory_order - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/load202e.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}#toc{display:none}.editsection{display:none}

/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:4:b677bc2b5ec37947892a2d0853532528 */</style>
<script src="../../../common/load404e.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "cpp/atomic/memory_order", "wgTitle": "cpp/atomic/memory order", "wgCurRevisionId": 47271, "wgArticleId": 2839, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Todo with reason", "Todo without reason"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_atomic_memory_order action-view skin-cppreference2 cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">
<span style="font-size:0.7em; line-height:130%">std::</span>memory_order</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a> | <a href="../atomic.html" title="cpp/atomic">atomic</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="line-height:1.1em;">

<tr>
<td colspan="5">  <a href="../language.html" title="cpp/language"> Language</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../header.html" title="cpp/header"> Standard library headers</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../concept.html" title="cpp/concept"> Concepts</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../utility.html" title="cpp/utility"> Utilities library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../string.html" title="cpp/string"> Strings library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../container.html" title="cpp/container"> Containers library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../iterator.html" title="cpp/iterator"> Iterators library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../numeric.html" title="cpp/numeric"> Numerics library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../io.html" title="cpp/io"> Input/output library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../locale.html" title="cpp/locale"> Localizations library</a>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>

<tr>
<td colspan="5">  <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark">(C++11)</span>
</td>
</tr>
</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="">

<tr class="t-sb-list-h1">
<td colspan="5">  Types
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic.html" title="cpp/atomic/atomic">atomic</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_is_lock_free.html" title="cpp/atomic/atomic is lock free">atomic_is_lock_free</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Functions
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_store.html" title="cpp/atomic/atomic store">atomic_store<br>atomic_store_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_load.html" title="cpp/atomic/atomic load">atomic_load<br>atomic_load_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_exchange.html" title="cpp/atomic/atomic exchange">atomic_exchange<br>atomic_exchange_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_compare_exchange.html" title="cpp/atomic/atomic compare exchange">atomic_compare_exchange_weak<br>atomic_compare_exchange_weak_explicit<br>atomic_compare_exchange_strong<br>atomic_compare_exchange_strong_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_add.html" title="cpp/atomic/atomic fetch add">atomic_fetch_add<br>atomic_fetch_add_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_sub.html" title="cpp/atomic/atomic fetch sub">atomic_fetch_sub<br>atomic_fetch_sub_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_and.html" title="cpp/atomic/atomic fetch and">atomic_fetch_and<br>atomic_fetch_and_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_or.html" title="cpp/atomic/atomic fetch or">atomic_fetch_or<br>atomic_fetch_or_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_xor.html" title="cpp/atomic/atomic fetch xor">atomic_fetch_xor<br>atomic_fetch_xor_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Atomic flags
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag.html" title="cpp/atomic/atomic flag">atomic_flag</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_test_and_set.html" title="cpp/atomic/atomic flag test and set">atomic_flag_test_and_set<br>atomic_flag_test_and_set_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_clear.html" title="cpp/atomic/atomic flag clear">atomic_flag_clear<br>atomic_flag_clear_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Initialization
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_init.html" title="cpp/atomic/atomic init">atomic_init</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="ATOMIC_VAR_INIT.html" title="cpp/atomic/ATOMIC VAR INIT">ATOMIC_VAR_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="ATOMIC_FLAG_INIT.html" title="cpp/atomic/ATOMIC FLAG INIT">ATOMIC_FLAG_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>


<tr class="t-sb-list-h1">
<td colspan="5">  Memory ordering
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><strong class="selflink">memory_order</strong></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="kill_dependency.html" title="cpp/atomic/kill dependency">kill_dependency</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">atomic_thread_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

<tr>
<td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_signal_fence.html" title="cpp/atomic/atomic signal fence">atomic_signal_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td>
</tr>

</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<table class="t-ddcl-list">
<tr class="t-ddcl-list-header">
<td> <div>Defined in header <code><a href="http://en.cppreference.com/mwiki/index.php" class="new" title="cpp/header/atomic (page does not exist)">&lt;atomic&gt;</a></code>
 </div>
</td>
<td></td>
<td></td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
<tr class="t-ddcl-list-item">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw2">enum</span> memory_order <span class="br0">{</span><br>
<p>    memory_order_relaxed,<br>
    memory_order_consume,<br>
    memory_order_acquire,<br>
    memory_order_release,<br>
    memory_order_acq_rel,<br>
    memory_order_seq_cst<br>
</p>
<span class="br0">}</span><span class="sy4">;</span></span></div>
</td>
<td class="t-ddcl-list-item-nopad">  </td>
<td> <span class="t-mark">(since C++11)</span> </td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
</table>
<p><code>std::memory_order</code> specifies how regular (non-atomic) memory accesses are to be ordered around an atomic operation. The rationale of this is that when several threads simultaneously read and write to several variables on multi-core systems, one thread might <i>see</i> the values change in different order than another thread has written them. Also, the apparent order of changes may be different across several reader threads. Ensuring that all memory accesses to atomic variables are sequential may hurt performance in some cases. <code>std::memory_order</code> allows to specify the exact constraints that the compiler must enforce.
</p>
<p>It's possible to specify custom memory order for each atomic operation in the library via an additional parameter. The default is <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span></span>.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Constants"><span class="tocnumber">1</span> <span class="toctext">Constants</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#Formal_description"><span class="tocnumber">2</span> <span class="toctext">Formal description</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Sequenced-before"><span class="tocnumber">2.1</span> <span class="toctext">Sequenced-before</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Carries_dependency"><span class="tocnumber">2.2</span> <span class="toctext">Carries dependency</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Modification_order"><span class="tocnumber">2.3</span> <span class="toctext">Modification order</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Release_sequence"><span class="tocnumber">2.4</span> <span class="toctext">Release sequence</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Dependency-ordered_before"><span class="tocnumber">2.5</span> <span class="toctext">Dependency-ordered before</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Inter-thread_happens-before"><span class="tocnumber">2.6</span> <span class="toctext">Inter-thread happens-before</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Happens-before"><span class="tocnumber">2.7</span> <span class="toctext">Happens-before</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Visible_side-effects"><span class="tocnumber">2.8</span> <span class="toctext">Visible side-effects</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Consume_operation"><span class="tocnumber">2.9</span> <span class="toctext">Consume operation</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Acquire_operation"><span class="tocnumber">2.10</span> <span class="toctext">Acquire operation</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Release_operation"><span class="tocnumber">2.11</span> <span class="toctext">Release operation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14">
<a href="#Explanation"><span class="tocnumber">3</span> <span class="toctext">Explanation</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Relaxed_ordering"><span class="tocnumber">3.1</span> <span class="toctext">Relaxed ordering</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Release-Acquire_ordering"><span class="tocnumber">3.2</span> <span class="toctext">Release-Acquire ordering</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Release-Consume_ordering"><span class="tocnumber">3.3</span> <span class="toctext">Release-Consume ordering</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Sequentially-consistent_ordering"><span class="tocnumber">3.4</span> <span class="toctext">Sequentially-consistent ordering</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Relationship_with_volatile"><span class="tocnumber">4</span> <span class="toctext">Relationship with volatile</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Constants">edit</a>]</span> <span class="mw-headline" id="Constants">Constants</span>
</h3>
<table class="t-dcl-list">

<tr class="t-dcl-list-header">
<td colspan="2"> <div>Defined in header <code><a href="http://en.cppreference.com/mwiki/index.php" class="new" title="cpp/header/atomic (page does not exist)">&lt;atomic&gt;</a></code> </div>
</td>
</tr>

<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-hitem">
<td>  Value
</td>
<td>  Explanation
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_relaxed</code>
</td>
<td>  <b>Relaxed</b> ordering: there are no synchronization or ordering constraints, only atomicity is required of this operation.
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_consume</code>
</td>
<td>  A load operation with this memory order performs a <b>consume</b> operation on the affected memory location: prior writes to data-dependent memory locations made by the thread that did a release operation become visible to this thread.
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_acquire</code>
</td>
<td>  A load operation with this memory order performs the <b>acquire</b> operation on the affected memory location: prior writes made to other memory locations by the thread that did the release become visible in this thread.
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_release</code>
</td>
<td>  A store operation with this memory order performs the <b>release</b> operation: prior writes to other memory locations become visible to the threads that do a consume or an acquire on the same location.
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_acq_rel</code>
</td>
<td>  A load operation with this memory order performs the <b>acquire</b> operation on the affected memory location and a store operation with this memory order performs the <b>release</b> operation.
</td>
</tr>


<tr class="t-dcl-list-sep">
<td colspan="2">
</td>
</tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_seq_cst</code>
</td>
<td>  Same as <code>memory_order_acq_rel</code>, and a single total order exists in which all threads observe all modifications (see below)
</td>
</tr>

</table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Formal description">edit</a>]</span> <span class="mw-headline" id="Formal_description">Formal description</span>
</h3>
<p>Inter-thread synchronization and memory ordering determine how <i>evaluations</i> and <i>side effects</i> of expressions are ordered between different threads of execution. They are defined in the following terms:
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: should be moved to its own page, like evaluation_order </td>
</tr></table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Sequenced-before">edit</a>]</span> <span class="mw-headline" id="Sequenced-before">Sequenced-before</span>
</h4>
<p>Within the same thread, evaluation A may be <i>sequenced-before</i> evaluation B, as described in <a href="../language/eval_order.html" title="cpp/language/eval order">evaluation order</a>.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Carries dependency">edit</a>]</span> <span class="mw-headline" id="Carries_dependency">Carries dependency</span>
</h4>
<p>Within the same thread, evaluation A that is <i>sequenced-before</i> evaluation B may also carry a dependency into B (that is, B depends on A), if any of the following is true
</p>
<div class="t-li1">
<span class="t-li">1)</span> The value of A is used as an operand of B, <b>except</b>
</div>
<div class="t-li2">
<span class="t-li">a)</span> if B is a call to <span class="mw-geshi cpp source-cpp"><a href="kill_dependency.html"><span class="kw1761">std::<span class="me2">kill_dependency</span></span></a></span>
</div>
<div class="t-li2">
<span class="t-li">b)</span> if A is the left operand of the built-in <span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;&amp;</span></span>, <span class="mw-geshi cpp source-cpp"><span class="sy3">||</span></span>, <span class="mw-geshi cpp source-cpp"><span class="sy4">?:</span></span>, or <span class="mw-geshi cpp source-cpp">,</span> operators.</div>
<div class="t-li1">
<span class="t-li">2)</span> A writes to a scalar object M, B reads from M, and A is <i>sequenced-before</i> B</div>
<div class="t-li1">
<span class="t-li">3)</span> A carries dependency into another evaluation X, and X carries dependency into B</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Modification order">edit</a>]</span> <span class="mw-headline" id="Modification_order">Modification order</span>
</h4>
<p>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.
</p>
<p>The following three requirements are guaranteed for all atomic operations:
</p>
<div class="t-li1">
<span class="t-li">1)</span> <b>Write-write coherence</b>: If evaluation A that modifies some atomic M (a write) <i>happens-before</i> evaluation B that modifies M, then A appears earlier than B in the <i>modification order</i> of M</div>
<div class="t-li1">
<span class="t-li">2)</span> <b>Read-read coherence</b>: if a value computation A of some atomic M (a read) <i>happens-before</i> a value computation B on M, and if the value of A comes from a write X on M, then the value of B is either the value stored by X, or the value stored by a side effect Y on M that appears later than X in the <i>modification order</i> of M.</div>
<div class="t-li1">
<span class="t-li">3)</span> <b>Read-write coherence</b>: if a value computation A of some atomic M (a read) <i>happens-before</i> an operation B on M (a write), then the value of A comes from a side-effect (a write) X that appears earlier than B in the <i>modification order</i> of M</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release sequence">edit</a>]</span> <span class="mw-headline" id="Release_sequence">Release sequence</span>
</h4>
<p>After a <i>release operation</i> A is performed on an atomic object M, the longest continuous subsequence of the modification order of M that consists of
</p>
<div class="t-li1">
<span class="t-li">1)</span> Writes performed by the same thread that performed A</div>
<div class="t-li1">
<span class="t-li">2)</span> Atomic read-modify-write operations made to M by any thread
is known as <i>release sequence headed by A</i>
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Dependency-ordered before">edit</a>]</span> <span class="mw-headline" id="Dependency-ordered_before">Dependency-ordered before</span>
</h4>
<p>Between threads, evaluation A is <i>dependency-ordered before</i> evaluation B if any of the following is true
</p>
<div class="t-li1">
<span class="t-li">1)</span> A performs a <i>release operation</i> on some atomic M, and, in a different thread, B performs a <i>consume operation</i> on the same atomic M, and B reads a value written by any part of the release sequence headed by A.</div>
<div class="t-li1">
<span class="t-li">2)</span> A is dependency-ordered before X and X carries a dependency into B.</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Inter-thread happens-before">edit</a>]</span> <span class="mw-headline" id="Inter-thread_happens-before">Inter-thread happens-before</span>
</h4>
<p>Between threads, evaluation A <i>inter-thread happens before</i> evaluatino B if any of the following is true
</p>
<div class="t-li1">
<span class="t-li">1)</span> A <i>synchronizes-with</i> B</div>
<div class="t-li1">
<span class="t-li">2)</span> A is <i>dependency-ordered before</i> B</div>
<div class="t-li1">
<span class="t-li">3)</span> A <i>synchronizes-with</i> some evaluation X, and X is <i>sequenced-before</i> B</div>
<div class="t-li1">
<span class="t-li">3)</span> A is <i>sequenced-before</i> some evaluation X, and X <i>inter-thread happens-before</i> B</div>
<div class="t-li1">
<span class="t-li">4)</span> A <i>inter-thread happens-before</i> some evaluation X, and X <i>inter-thread happens-before</i> B</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Happens-before">edit</a>]</span> <span class="mw-headline" id="Happens-before">Happens-before</span>
</h4>
<p>Regardless of threads, evaluation A <i>happens-before</i> evaluation B if any of the following is true:
</p>
<div class="t-li1">
<span class="t-li">1)</span> A is <i>sequenced-before</i> B</div>
<div class="t-li1">
<span class="t-li">2)</span> A <i>inter-thread happens before</i> B</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Visible side-effects">edit</a>]</span> <span class="mw-headline" id="Visible_side-effects">Visible side-effects</span>
</h4>
<p>The side-effect A on a scalar M (a write) is <i>visible</i> with respect to value computation B on M (a read) if both of the following are true:
</p>
<div class="t-li1">
<span class="t-li">1)</span> A <i>happens-before</i> B</div>
<div class="t-li1">
<span class="t-li">2)</span> There is no other side effect X to M where A <i>happens-before</i> X and X <i>happens-before</i> B</div>
<p>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in <i>modification order</i>, where B does not <i>happen-before</i> it is known as the <i>visible sequence of side-effects</i>. (the value of M, determined by B, will be the value stored by one of these side effects)
</p>
<p>Note: inter-thread synchronization boils down to defining which side effects become visible under what conditions
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Consume operation">edit</a>]</span> <span class="mw-headline" id="Consume_operation">Consume operation</span>
</h4>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete </td>
</tr></table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Acquire operation">edit</a>]</span> <span class="mw-headline" id="Acquire_operation">Acquire operation</span>
</h4>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete </td>
</tr></table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release operation">edit</a>]</span> <span class="mw-headline" id="Release_operation">Release operation</span>
</h4>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete </td>
</tr></table>
<p><br>
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span>
</h3>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relaxed ordering">edit</a>]</span> <span class="mw-headline" id="Relaxed_ordering">Relaxed ordering</span>
</h4>
<p>Atomic operations tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_relaxed</span></span> are not synchronization operations, they do not order memory. They only guarantee atomicity and  modification order consistency.
</p>
<p>For example, with <code>x</code> and <code>y</code> initially zero,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// Thread 1:</span>
r1 <span class="sy1">=</span> y.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A</span>
x.<span class="me1">store</span><span class="br0">(</span>r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// B</span>
<span class="co1">// Thread 2:</span>
r2 <span class="sy1">=</span> x.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// C </span>
y.<span class="me1">store</span><span class="br0">(</span><span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D</span></pre></div></div>
<p>is allowed to produce <code>r1 == r2 == 42</code> because, although A is <i>sequenced-before</i> B and C is <i>sequenced before</i> D, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x.
</p>
<div class="t-example">
<p> Updating the same global counter from multiple threads requires atomicity, but no synchronization or ordering
 </p>
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3nfBe-HUNthGeeBZEgJ_TmEihAHs0Z4WXSzjEgkouYbub0wtZxPf-k_t7DLZXU8Aj__SKcmRQlZ29mUl2puWjMz2nC7vvq_ZejJx7qhz4-jTXLIBPI-sXWGd3VSBIh3IaRSz_Ya_B0ZlyqPJFTHUjsdC20Ov-NQ63kL3NlJJ5XOEPNSRubOiRBy-taqZDMO4EXoEj9zBYDx0FVou6b3I-kKuWSIO5ZJTX6fP6LkcQbcXyyjJu1p_0BPrUCFx92geKg9tfURAGibq-bja2xpwJ5rur4dhaHn2Iy9feqPAghkZ4eEocrzvaoGnVCy41zTfc_QLoYHsz6YwLLlL8UALesPAd6pIbQ1hL82vGKBj9A==" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
 
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> cnt <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1759">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">1000</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        cnt.<span class="me1">fetch_add</span><span class="br0">(</span><span class="nu0">1</span>, std<span class="sy4">::</span><span class="me2">memory_order_relaxed</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        v.<span class="me1">emplace_back</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span> t <span class="sy4">:</span> v<span class="br0">)</span> <span class="br0">{</span>
        t.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <a href="../io/basic_ostream.html"><span class="kw1428">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Final counter value is "</span> <span class="sy1">&lt;&lt;</span> cnt <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Final counter value is 10000</pre></div></div> 
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Acquire ordering">edit</a>]</span> <span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span>
</h4>
<p>If an atomic store in thread A is tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_acquire</span></span>, all memory writes (non-atomic and relaxed atomic) that <i>happened-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.
</p>
<p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p>
<p>On strongly-ordered systems (x86, SPARC, IBM mainframe), release-acquire ordering is automatic. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-release or perform non-atomic loads earlier than the atomic load-acquire)
</p>
<p>Mutual exclusion locks (such as <span class="mw-geshi cpp source-cpp"><a href="../thread/mutex.html"><span class="kw1770">std::<span class="me2">mutex</span></span></a></span> or <a href="atomic_flag.html" title="cpp/atomic/atomic flag">atomic spinlock</a>) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.
</p>
<div class="t-example">
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3n_Ad8XSNsRFeeLj99ZMGqqj_BfdLZRufDtakGGdwTN5z7NTZxZHR-oWF6TO7OS0q_Rl0Srcx1Vb3j_hZVEy_IsXLpZlAhltCpJ9WXtHA4sTnqOkCseyA8OJQWzKkYBfM9-K-mi88icceyWuN3IBMwiqqr4PL2cr_jwkWhlZWlwYVN7MKr1fLQUMuZytmsBYrsLtPlcdpgwGKO-pJYcZx2D6CQ-G_iB93NMeNURzvdXSZKmJLqyBB9GqK4SI84dOqlhI5CUQHSZK89nteaTCup2ARDciwKrdYB75d947bML4m7k6_hApO4tZ_gq3JmEcnwQgMGe0RMg03_lf1Q82q-IE-dhXFSkGNO1T2aFj" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_acquire</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<div class="t-example">
<p> The following example demonstrates transitive release-acquire ordering across three threads
 </p>
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3mcAd8XSNth_cbJV4socCqnHJO0q-mPvVKE8lHZBWL3F-Upi5cLEL_-C0IeVJ-hBtt-BPegiXK79VC4POV5QA_XPXOgBPoCG-pZGPFKoewNYAXJvqN_Dke7ROd5rDJJDufq798XwFFeQk4br14VjbNyXFIsVbBtkRY6PTEvkJVu7nxY0L43cv1DE2_Ewiygr4sd_8c-79q17CotBKsbHhx0kNVnycQETMpC-4bnExPpLFl5iElCErqFfuKlLxXIknqZKcPvzbXZk6QxrfVwAkVFEyZO-MoT95r3n6FQhzvqhGiAFdCSKUznI974E8qQSr8cBemAAuic0C2wCzBhQsVQ65TCSqiHNtjOB1LaR6GmwJScmnTF1_7WFm6AFCCDGMqIzXjnPFkA7sDUvw_HbjqKNNKQNkCwHHB6I-krl9U0-0x7uQ3zEQlTgXxtcnBWb" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
 
<a href="../container/vector.html"><span class="kw1058">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> data<span class="sy4">;</span>
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> flag <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1759">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> thread_1<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    data.<span class="me1">push_back</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
    flag.<span class="me1">store</span><span class="br0">(</span><span class="nu0">1</span>, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_2<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> expected<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>flag.<span class="me1">compare_exchange_strong</span><span class="br0">(</span>expected, <span class="nu0">2</span>, std<span class="sy4">::</span><span class="me2">memory_order_acq_rel</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        expected <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_3<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>flag.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_acquire</span><span class="br0">)</span> <span class="sy1">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data.<span class="me1">at</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// will never fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>thread_1<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>thread_2<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>thread_3<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p><br>
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Consume ordering">edit</a>]</span> <span class="mw-headline" id="Release-Consume_ordering">Release-Consume ordering</span>
</h4>
<p>If an atomic store in thread A is tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_consume</span></span>, all memory writes (non-atomic and relaxed atomic) that are <i>dependency-ordered-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything that thread A wrote to memory if it carries a data dependency into the atomic load.
</p>
<p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p>
<p>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain)
</p>
<div class="t-example">
<p> This example demonstrates dependency-ordered synchronization: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.
 </p>
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3n_A8cXTJtgm7UG2_bN1jQODCbbMhvk61D8FndC0XtscdpsqVlgqi4uNp30PFB3KXPbz8kuyiNU96XLUCZ4A59jw2vn8aTdtBCVfnq8QqfEwAYDX2WPX9VvCu2vi9v4D29-O1mj8_AcclTrC3OnBMDM8kc4JCycPSNCbhoFFGSjn45Zk_bDRoAcA-RysmsBYqsJtr6KNhLcODZvk4H3UAkcWXa2QvMJIfPNK8pyf583EqrOK1UociVkLqOiUewBA5U5eaDk3wVtCP2Rji3VCDP9tnN5OmJxpvEs8iwWFc56kn7EKNYEYELylDgMwEWa9Mm8EFprONkYMgGq-v1eSSIPCflc4jsGXKUhNKzePmotSRRs=" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1037">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_consume</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// may or may not fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p><br>
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Sequentially-consistent ordering">edit</a>]</span> <span class="mw-headline" id="Sequentially-consistent_ordering">Sequentially-consistent ordering</span>
</h4>
<p>Atomic operations tagged <span class="mw-geshi cpp source-cpp">std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span></span> not only order memory the same way as release/consume ordering (everything that happened-before a store in one thread becomes a visible side effect in the tread that did a load), but, in addition, establish a single total modification order of all atomic operations that are so tagged.
</p>
<p>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.
</p>
<p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.
</p>
<div class="t-example">
<p> This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads <code>c</code> and <code>d</code> to observe changes to the atomics <code>x</code> and <code>y</code> in opposite order.
 </p>
<div class="t-example-live-link"><a href="http://liveworkspace.org/api/cppreference.com/clangpp/1005f9f891bb264c0273672491cda0bfh9PiNCpmKGQJ3p8DdcSSNtw8cTfKgAoNaepIG47ivYqd0IexgIEYhFlZyLTuR9iSOyV4gnkJ6VCPKqVw7LX7oBDgbxe765ZEpWDSXy1uE7DLq0KxB6bml6gtaGNUsQ2hBoNbl6xx-Gw1rL_Ts8IP_iCmbVU4DSm-Le-2DeG6-8vMRmJNje3zJXm8qwi99vBZGXQqNg8qzOF7jZKBD-SZS2fSWFKEQ01Gdxqs0XhmO2tGmfHxL67fvq1_gs8Gas-rtfhmcZf4HLbx2WI9Auw5bhb-vwb8_MXGUZuAp5Oxf3f13j2OPWYVp2Vy_ZkaYJCEgEmO_CkdhXL2FhMGr2HXpwo1GGiksrSJ-wVXLKWckhlnEps6arOhQiDCa_kfX9AIQBNnK2MkDp9mDgUDtYMyn4xULsgXm3FQla9teBd0P0yhJXZqEg==" class="external text">run this code</a></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
 
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> x <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1759">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> y <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1759">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1735">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1759">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> write_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    x.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> write_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    y.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_x_then_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>x.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>y.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_y_then_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>y.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>x.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>write_x<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>write_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>read_x_then_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1764">std::<span class="me2">thread</span></span></a> d<span class="br0">(</span>read_y_then_x<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> d.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>z.<span class="me1">load</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// will never happen</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relationship with volatile">edit</a>]</span> <span class="mw-headline" id="Relationship_with_volatile">Relationship with <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span></span>
</h3>
<p>Within a thread of execution, accesses (reads and writes) to all <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> objects are guaranteed to not be reordered relative to each other, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.
</p>
<p>In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).
</p>
<p>One notable exception is Visual Studio, where every volatile write has release semantics and every volatile read has acquire semantics (<a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx">MSDN</a>), and thus volatiles may be used for inter-thread synchronization. Standard <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a signal handler (see also <span class="mw-geshi cpp source-cpp"><a href="atomic_signal_fence.html"><span class="kw1763">std::<span class="me2">atomic_signal_fence</span></span></a></span>)
</p>
<!-- 
NewPP limit report
Preprocessor node count: 3199/1000000
Post-expand include size: 65211/2097152 bytes
Template argument size: 32402/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:2839-0!*!0!!en!*!* and timestamp 20130503133756 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=47271</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special:Categories" title="Special:Categories">Categories</a>: <ul>
<li><a href="http://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li>
<li><a href="http://en.cppreference.com/w/Category:Todo_without_reason" title="Category:Todo without reason">Todo without reason</a></li>
</ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script src="../../../common/loadac2a.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script src="../../../common/load345b.php"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0
	,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:4:3740695a1552aee37d594967bd36f869 */
}
</script>
<!-- Served in 0.063 secs. -->        
	</body>
<!-- Cached 20130503134600 -->



</html>
